<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADK-Programmers-Guides: IPC Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="verifone.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="verifonelogo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADK-Programmers-Guides
   &#160;<span id="projectnumber">5.0.3-CD1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classvfiipc_1_1_i_p_c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">IPC Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ipc_8h_source.html">ipc.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IPC:</div>
<div class="dyncontent">
<div class="center"><img src="classvfiipc_1_1_i_p_c__inherit__graph.png" border="0" usemap="#_i_p_c_inherit__map" alt="Inheritance graph"/></div>
<map name="_i_p_c_inherit__map" id="_i_p_c_inherit__map">
<area shape="rect" title=" " alt="" coords="83,5,125,32"/>
<area shape="rect" href="classvfiipc_1_1_pipe.html" title=" " alt="" coords="5,80,56,107"/>
<area shape="rect" href="classvfiipc_1_1_t_c_p.html" title=" " alt="" coords="81,80,127,107"/>
<area shape="rect" href="classvfiipc_1_1_t_l_s.html" title=" " alt="" coords="152,80,197,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2de5cc01b541095acf2fa6d8f1efcefd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a2de5cc01b541095acf2fa6d8f1efcefd">~IPC</a> ()</td></tr>
<tr class="separator:a2de5cc01b541095acf2fa6d8f1efcefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044713f1fcbdbec24aae467186a95481"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a044713f1fcbdbec24aae467186a95481">eof</a> ()</td></tr>
<tr class="separator:a044713f1fcbdbec24aae467186a95481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090dfa7806330da64843832e3985ebdf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a090dfa7806330da64843832e3985ebdf">error</a> ()</td></tr>
<tr class="separator:a090dfa7806330da64843832e3985ebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05fb9ec7fd0b49be32e902bf5f485cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#ad05fb9ec7fd0b49be32e902bf5f485cd">accept</a> (int timeout_msec=-1)</td></tr>
<tr class="separator:ad05fb9ec7fd0b49be32e902bf5f485cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47feccb1873356363e4d0e302bc3822c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a47feccb1873356363e4d0e302bc3822c">close</a> ()</td></tr>
<tr class="separator:a47feccb1873356363e4d0e302bc3822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f753a2a5691e2d36266e2ff084a217"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a04f753a2a5691e2d36266e2ff084a217">write</a> (const void *data, int size)</td></tr>
<tr class="separator:a04f753a2a5691e2d36266e2ff084a217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04744c17ae9eec2b37fb8c476a8c62d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#aa04744c17ae9eec2b37fb8c476a8c62d">read</a> (void *data, int maxsize, int timeout_msec, int timeout_msec2)</td></tr>
<tr class="separator:aa04744c17ae9eec2b37fb8c476a8c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69117eaa93a4a8bff9cb28df51abc50b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a69117eaa93a4a8bff9cb28df51abc50b">read</a> (void *data, int maxsize, int timeout_msec=-1)</td></tr>
<tr class="separator:a69117eaa93a4a8bff9cb28df51abc50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe719544c505e175fe68e0c616f9742d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#abe719544c505e175fe68e0c616f9742d">peek</a> (void *data, int maxsize, int timeout_msec=-1)</td></tr>
<tr class="separator:abe719544c505e175fe68e0c616f9742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa847963eee355eaa6d9054510fb66b65"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#aa847963eee355eaa6d9054510fb66b65">write_msg</a> (unsigned prefix, int msg_id, const void *msg, int size)</td></tr>
<tr class="separator:aa847963eee355eaa6d9054510fb66b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0117598edfaf3ed682337421457956"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#adf0117598edfaf3ed682337421457956">write_msg</a> (unsigned prefix, int msg_id, const std::vector&lt; unsigned char &gt; &amp;msg)</td></tr>
<tr class="separator:adf0117598edfaf3ed682337421457956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e36d031eb96fa532e70d99dd6454864"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a0e36d031eb96fa532e70d99dd6454864">write_msg</a> (unsigned prefix, int msg_id, const std::vector&lt; char &gt; &amp;msg)</td></tr>
<tr class="separator:a0e36d031eb96fa532e70d99dd6454864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc3e8a54237502339f9483465730704"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a5fc3e8a54237502339f9483465730704">read_msg</a> (unsigned prefix, int &amp;msg_id, std::vector&lt; unsigned char &gt; &amp;msg, int size_limit, int timeout_msec=-1)</td></tr>
<tr class="separator:a5fc3e8a54237502339f9483465730704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b26f735493cab66dbb7bbffe6d2190"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#af9b26f735493cab66dbb7bbffe6d2190">read_msg</a> (unsigned prefix, int &amp;msg_id, std::vector&lt; char &gt; &amp;msg, int size_limit, int timeout_msec=-1)</td></tr>
<tr class="separator:af9b26f735493cab66dbb7bbffe6d2190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3d66ed5454894b1ace225e51de8674"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#aae3d66ed5454894b1ace225e51de8674">poll_in</a> (int timeout_msec=-1)</td></tr>
<tr class="separator:aae3d66ed5454894b1ace225e51de8674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c43ffa916e2d7662a667b33646493a"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#af5c43ffa916e2d7662a667b33646493a">remote_addr</a> () const</td></tr>
<tr class="separator:af5c43ffa916e2d7662a667b33646493a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da953859d766be3eb7a8409fc9a6b02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a2da953859d766be3eb7a8409fc9a6b02">getFD</a> () const</td></tr>
<tr class="separator:a2da953859d766be3eb7a8409fc9a6b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e8080bdf5412792220bbb47cd2f4d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#aa73e8080bdf5412792220bbb47cd2f4d">set_callback</a> (<a class="el" href="namespacevfiipc.html#ad81e4165dd387a02aacdb8a57c4fdd4f">ipcCallback</a> cb, void *data=0)</td></tr>
<tr class="separator:aa73e8080bdf5412792220bbb47cd2f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ade24ef1ee0c1c277e735e10288bea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#aa3ade24ef1ee0c1c277e735e10288bea">write_msg</a> (unsigned prefix, int msg_id, const std::string &amp;msg)</td></tr>
<tr class="separator:aa3ade24ef1ee0c1c277e735e10288bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12475d631dd0313083d53b72d007a07a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a12475d631dd0313083d53b72d007a07a">read_msg</a> (unsigned prefix, int &amp;msg_id, std::string &amp;msg, int size_limit, int timeout_msec=-1)</td></tr>
<tr class="separator:a12475d631dd0313083d53b72d007a07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfdf57c1c76dcccb680e6dabdfdf59e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#acdfdf57c1c76dcccb680e6dabdfdf59e">is_server</a> ()</td></tr>
<tr class="separator:acdfdf57c1c76dcccb680e6dabdfdf59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa992c5725a59c6d865dc28415862eb1e"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#aa992c5725a59c6d865dc28415862eb1e">local_addr</a> () const</td></tr>
<tr class="separator:aa992c5725a59c6d865dc28415862eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a78d252e52f513e6ddfb13d8e4a5ebb6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="libseccmd-comp_8h.html#ac1e8a42306d8e67cb94ca31c3956ee78">DEPRECATED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a78d252e52f513e6ddfb13d8e4a5ebb6d">set_callback_stacksize</a> (int size=-1)</td></tr>
<tr class="separator:a78d252e52f513e6ddfb13d8e4a5ebb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add90ed6ce299e1afd9cf2ddf23e3b722"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#add90ed6ce299e1afd9cf2ddf23e3b722">getVersion</a> ()</td></tr>
<tr class="separator:add90ed6ce299e1afd9cf2ddf23e3b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb74a0c7649adcd2699a37099e67407"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#adbb74a0c7649adcd2699a37099e67407">ipc_GetVersion</a> ()</td></tr>
<tr class="separator:adbb74a0c7649adcd2699a37099e67407"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8ad54b08db43652b4d971a7ae17e1634"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a8ad54b08db43652b4d971a7ae17e1634">IPC</a> (IpcPrivate *_d)</td></tr>
<tr class="separator:a8ad54b08db43652b4d971a7ae17e1634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566bc069efbaf8b7c6d7639cf6a0a7ea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a566bc069efbaf8b7c6d7639cf6a0a7ea">read_msg</a> (unsigned prefix, int &amp;msg_id, IpcBuffer &amp;msg, int size_limit, int timeout_msec=-1)</td></tr>
<tr class="separator:a566bc069efbaf8b7c6d7639cf6a0a7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a40526579f289c2f9a91bde432367b54b"><td class="memItemLeft" align="right" valign="top">IpcPrivate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvfiipc_1_1_i_p_c.html#a40526579f289c2f9a91bde432367b54b">d</a></td></tr>
<tr class="separator:a40526579f289c2f9a91bde432367b54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>base class for inter process communication. Both stream and message based operation is supported. For messages the message format is as follows:<br  />
&lt;4 bytes prefix&gt; &lt;4 bytes message size&gt; &lt;4 bytes message ID&gt; &lt;message&gt;<br  />
All numbers are in big endian format. Size includes the size of the message ID. The prefix is used for checking synchronization of sender and receiver and is used to re-synchronize in case synchonization has been lost: The receiver discards data until a valid prefix has been found. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8ad54b08db43652b4d971a7ae17e1634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad54b08db43652b4d971a7ae17e1634">&#9670;&nbsp;</a></span>IPC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> </td>
          <td>(</td>
          <td class="paramtype">IpcPrivate *&#160;</td>
          <td class="paramname"><em>_d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>constructor </p>

</div>
</div>
<a id="a2de5cc01b541095acf2fa6d8f1efcefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de5cc01b541095acf2fa6d8f1efcefd">&#9670;&nbsp;</a></span>~IPC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad05fb9ec7fd0b49be32e902bf5f485cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05fb9ec7fd0b49be32e902bf5f485cd">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a>* accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>accept an incoming connection for <em>timeout_msec</em> milliseconds. A negative value means wait forever. Please note that <a class="el" href="classvfiipc_1_1_i_p_c.html#ad05fb9ec7fd0b49be32e902bf5f485cd">accept()</a> only works for <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> objecst in server mode (e.g. see <a class="el" href="classvfiipc_1_1_t_c_p.html#ae4ffb5366b5b327f89b3b4624823e4c4">TCP::listen()</a> or <a class="el" href="classvfiipc_1_1_pipe.html#a29ad40613be45421828668eb96335a0c">Pipe::listen()</a>). If an incoming connection has been accepted a pointer to an object to this connection is returned that has been allocated using new. The caller takes over ownership for this object and if it is not needed any longer it must be released using delete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout to wait for a new connection in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a new <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> object on success, else NULL in case of timeout or error </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_pipe.html#a95b94113c8b49766182f98a1b5ed14fe">Pipe</a>, <a class="el" href="classvfiipc_1_1_t_c_p.html#a95b94113c8b49766182f98a1b5ed14fe">TCP</a>, and <a class="el" href="classvfiipc_1_1_t_l_s.html#a95b94113c8b49766182f98a1b5ed14fe">TLS</a>.</p>

</div>
</div>
<a id="a47feccb1873356363e4d0e302bc3822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47feccb1873356363e4d0e302bc3822c">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>close any open internal file descriptors </p>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_pipe.html#a5ae591df94fc66ccb85cbb6565368bca">Pipe</a>, <a class="el" href="classvfiipc_1_1_t_c_p.html#a5ae591df94fc66ccb85cbb6565368bca">TCP</a>, and <a class="el" href="classvfiipc_1_1_t_l_s.html#a5ae591df94fc66ccb85cbb6565368bca">TLS</a>.</p>

</div>
</div>
<a id="a044713f1fcbdbec24aae467186a95481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044713f1fcbdbec24aae467186a95481">&#9670;&nbsp;</a></span>eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns true, if <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> has indicated an EOF (end of file) and connection was closed. Invoke <a class="el" href="classvfiipc_1_1_i_p_c.html#a47feccb1873356363e4d0e302bc3822c">close()</a> function for re-use of this <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> object. </p>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#a044713f1fcbdbec24aae467186a95481">TLS</a>.</p>

</div>
</div>
<a id="a090dfa7806330da64843832e3985ebdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090dfa7806330da64843832e3985ebdf">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns true, <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> has indicated an error (e.g. connection is distrubed). Invoke <a class="el" href="classvfiipc_1_1_i_p_c.html#a47feccb1873356363e4d0e302bc3822c">close()</a> function for re-use of this <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> object. </p>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#a090dfa7806330da64843832e3985ebdf">TLS</a>.</p>

</div>
</div>
<a id="a2da953859d766be3eb7a8409fc9a6b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da953859d766be3eb7a8409fc9a6b02">&#9670;&nbsp;</a></span>getFD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getFD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>obtain the file descriptor used for reading/writing data </p><dl class="section return"><dt>Returns</dt><dd>file descriptor </dd></dl>

</div>
</div>
<a id="add90ed6ce299e1afd9cf2ddf23e3b722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add90ed6ce299e1afd9cf2ddf23e3b722">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a zero-terminated string with version and build information of libvfiipc </p><dl class="section return"><dt>Returns</dt><dd>version string </dd></dl>

</div>
</div>
<a id="adbb74a0c7649adcd2699a37099e67407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb74a0c7649adcd2699a37099e67407">&#9670;&nbsp;</a></span>ipc_GetVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* ipc_GetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a zero-terminated string with version and build information of libvfiipc in ADK version string format: &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;build&gt;, e.g. "1.2.3-4" </p><dl class="section return"><dt>Returns</dt><dd>version string </dd></dl>

</div>
</div>
<a id="acdfdf57c1c76dcccb680e6dabdfdf59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfdf57c1c76dcccb680e6dabdfdf59e">&#9670;&nbsp;</a></span>is_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool is_server </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns true, if this <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> object is a server instance, on which <a class="el" href="classvfiipc_1_1_t_c_p.html#ae4ffb5366b5b327f89b3b4624823e4c4">TCP::listen()</a> or <a class="el" href="classvfiipc_1_1_pipe.html#a29ad40613be45421828668eb96335a0c">Pipe::listen()</a> was called. \ return true if this <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> is used as server </p>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#acdfdf57c1c76dcccb680e6dabdfdf59e">TLS</a>.</p>

</div>
</div>
<a id="aa992c5725a59c6d865dc28415862eb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa992c5725a59c6d865dc28415862eb1e">&#9670;&nbsp;</a></span>local_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* local_addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For IPC::TCP objects: This function always returns the IP address and session port of the local interface used for the connection, string format is: "&amp;lt;IP address&gt;:&amp;lt;port&gt;". For IPC::Pipe objects: In difference to <a class="el" href="classvfiipc_1_1_i_p_c.html#af5c43ffa916e2d7662a667b33646493a">IPC::remote_addr()</a>, this function always returns an empty string. Use OS functions to get information for local PID, UID and GID. </p><dl class="section return"><dt>Returns</dt><dd>local information string or an empty string </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#aa992c5725a59c6d865dc28415862eb1e">TLS</a>.</p>

</div>
</div>
<a id="abe719544c505e175fe68e0c616f9742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe719544c505e175fe68e0c616f9742d">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int peek </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read data from the stream without removing it, the eof and error flags are not updated to not break a consecutive read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>buffer that will receive the read bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsize</td><td>maximum number of bytes to be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout for reading in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read. A short read does not indicate EOF, it just means that there is no more data to look at, 0 means EOF, -1 means error, -2 means timeout. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike read this function returns as soon as some data is available, it does not try to wait until maxsize bytes can be read. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is no virtual function to maintain ABI compatibility. </dd></dl>

</div>
</div>
<a id="aae3d66ed5454894b1ace225e51de8674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3d66ed5454894b1ace225e51de8674">&#9670;&nbsp;</a></span>poll_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool poll_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>check for availability of incoming data on the stream. In case of an error or an EOF this function also returns true and sets the internal flags for functions <a class="el" href="classvfiipc_1_1_i_p_c.html#a044713f1fcbdbec24aae467186a95481">IPC::eof()</a> and <a class="el" href="classvfiipc_1_1_i_p_c.html#a090dfa7806330da64843832e3985ebdf">IPC::error()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout to wait for available data in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of data is available (or EOF/error), else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#aae3d66ed5454894b1ace225e51de8674">TLS</a>.</p>

</div>
</div>
<a id="aa04744c17ae9eec2b37fb8c476a8c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04744c17ae9eec2b37fb8c476a8c62d">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>read data from the stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>buffer that will receive the read bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsize</td><td>number of bytes to be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout for reading in milliseconds. A negative timeout means wait forever. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec2</td><td>timeout for reading after at least one byte has been read in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read. A short read indicates EOF, timeout or error </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#aa04744c17ae9eec2b37fb8c476a8c62d">TLS</a>.</p>

</div>
</div>
<a id="a69117eaa93a4a8bff9cb28df51abc50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69117eaa93a4a8bff9cb28df51abc50b">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>read data from the stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>buffer that will receive the read bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsize</td><td>number of bytes to be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout for reading in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read. A short read indicates EOF, timeout or error </dd></dl>

</div>
</div>
<a id="a566bc069efbaf8b7c6d7639cf6a0a7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566bc069efbaf8b7c6d7639cf6a0a7ea">&#9670;&nbsp;</a></span>read_msg() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool read_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IpcBuffer &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>base function for reading messages </p>

</div>
</div>
<a id="a12475d631dd0313083d53b72d007a07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12475d631dd0313083d53b72d007a07a">&#9670;&nbsp;</a></span>read_msg() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool read_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>read message from the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The data stream is checked to start with <em>prefix</em>. This is used to re-synchronize on the incoming data stream if required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>received message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_limit</td><td>size limit to prevent exhaustive memory allocations in case corrupt data has been received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout for reading in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#a12475d631dd0313083d53b72d007a07a">TLS</a>.</p>

</div>
</div>
<a id="af9b26f735493cab66dbb7bbffe6d2190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b26f735493cab66dbb7bbffe6d2190">&#9670;&nbsp;</a></span>read_msg() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool read_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>read message from the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The data stream is checked to start with <em>prefix</em>. This is used to re-synchronize on the incoming data stream if required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>received message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_limit</td><td>size limit to prevent exhaustive memory allocations in case corrupt data has been received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout for reading in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#af9b26f735493cab66dbb7bbffe6d2190">TLS</a>.</p>

</div>
</div>
<a id="a5fc3e8a54237502339f9483465730704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc3e8a54237502339f9483465730704">&#9670;&nbsp;</a></span>read_msg() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool read_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>read message from the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The data stream is checked to start with <em>prefix</em>. This is used to re-synchronize on the incoming data stream if required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>received message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_limit</td><td>size limit to prevent exhaustive memory allocations in case corrupt data has been received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>timeout for reading in milliseconds. A negative timeout means wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#a5fc3e8a54237502339f9483465730704">TLS</a>.</p>

</div>
</div>
<a id="af5c43ffa916e2d7662a667b33646493a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c43ffa916e2d7662a667b33646493a">&#9670;&nbsp;</a></span>remote_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* remote_addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For IPC::TCP objects: This function always returns the IP address and session port of the connected client or server, string format is: "&amp;lt;IP address&gt;:&amp;lt;port&gt;". For IPC::Pipe objects: This function always returns PID, UID and GID of the remote process (string format: "&amp;lt;pid&gt; &amp;lt;uid&gt; &amp;lt;gid&gt;"). Since credential information is obtained from underlying OS, it is no longer necessary to enable <a class="el" href="classvfiipc_1_1_pipe.html#a892ce29b9c853749e7c4551f44fe2603a5f770eff268e3423ae7f928a3819e9cf">Pipe::PC_EnableCredentials</a>, which is deprecated since removal of Verix eVo. </p><dl class="section return"><dt>Returns</dt><dd>remote information string or an empty string </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#af5c43ffa916e2d7662a667b33646493a">TLS</a>.</p>

</div>
</div>
<a id="aa73e8080bdf5412792220bbb47cd2f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e8080bdf5412792220bbb47cd2f4d">&#9670;&nbsp;</a></span>set_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevfiipc.html#ad81e4165dd387a02aacdb8a57c4fdd4f">ipcCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>register a callback function for this <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> object, which is invoked, if incoming data is pending and that <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> functions <a class="el" href="classvfiipc_1_1_i_p_c.html#aa04744c17ae9eec2b37fb8c476a8c62d">read()</a> or <a class="el" href="classvfiipc_1_1_i_p_c.html#a5fc3e8a54237502339f9483465730704">read_msg()</a> can be called to read the data. Set cb to NULL to unregister the callback for this <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback function, which is invoked, if has been received. Passing a NULL pointer will unregister the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data pointer, which is passed to callback function <em>cb</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for success, else callback couldn't be registered/unregistered. </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#aa73e8080bdf5412792220bbb47cd2f4d">TLS</a>.</p>

</div>
</div>
<a id="a78d252e52f513e6ddfb13d8e4a5ebb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d252e52f513e6ddfb13d8e4a5ebb6d">&#9670;&nbsp;</a></span>set_callback_stacksize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="libseccmd-comp_8h.html#ac1e8a42306d8e67cb94ca31c3956ee78">DEPRECATED</a> void set_callback_stacksize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>callbacks configured with function <a class="el" href="classvfiipc_1_1_i_p_c.html#aa73e8080bdf5412792220bbb47cd2f4d">IPC::set_callback()</a> are invoked in context of a seperate thread that is started with first invocation of this function. </p><dl class="section note"><dt>Note</dt><dd>This function is deprecated since removal of Verix eVo. It is not recommended to modify thread stacksizes on other systems! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>stacksize of the thread (in bytes) invoking callback function registered with <a class="el" href="classvfiipc_1_1_i_p_c.html#aa73e8080bdf5412792220bbb47cd2f4d">IPC::set_callback()</a>. Please note that minimal required stacksize depends on the application code that is placed to the callback function. Minimal value is PTHREAD_STACK_MIN and sizes below this limit will set this minmal value. A negative size means the usage of the system default stacksize (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect, if the callback thread was already started by calling <a class="el" href="classvfiipc_1_1_i_p_c.html#aa73e8080bdf5412792220bbb47cd2f4d">IPC::set_callback()</a>. A running callback thread is not restarted with another stacksize. </dd></dl>

</div>
</div>
<a id="a04f753a2a5691e2d36266e2ff084a217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f753a2a5691e2d36266e2ff084a217">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>write data to the stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#a04f753a2a5691e2d36266e2ff084a217">TLS</a>.</p>

</div>
</div>
<a id="aa3ade24ef1ee0c1c277e735e10288bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ade24ef1ee0c1c277e735e10288bea">&#9670;&nbsp;</a></span>write_msg() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool write_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>write a message to the stream. The message is prefixed by <em>prefix</em> and the size of the message (big endian). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>prefix of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#aa3ade24ef1ee0c1c277e735e10288bea">TLS</a>.</p>

</div>
</div>
<a id="a0e36d031eb96fa532e70d99dd6454864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e36d031eb96fa532e70d99dd6454864">&#9670;&nbsp;</a></span>write_msg() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool write_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>write a message to the stream. The message is prefixed by <em>prefix</em> and the size of the message (big endian). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>prefix of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#a0e36d031eb96fa532e70d99dd6454864">TLS</a>.</p>

</div>
</div>
<a id="adf0117598edfaf3ed682337421457956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0117598edfaf3ed682337421457956">&#9670;&nbsp;</a></span>write_msg() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool write_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>write a message to the stream. The message is prefixed by <em>prefix</em> and the size of the message (big endian). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>prefix of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#adf0117598edfaf3ed682337421457956">TLS</a>.</p>

</div>
</div>
<a id="aa847963eee355eaa6d9054510fb66b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa847963eee355eaa6d9054510fb66b65">&#9670;&nbsp;</a></span>write_msg() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool write_msg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>write a message to the stream. The message is prefixed by <em>prefix</em> and the size of the message (including msg_id, big endian) and by 4 bytes message ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>prefix of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_id</td><td>message ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success, else false </dd></dl>

<p>Reimplemented in <a class="el" href="classvfiipc_1_1_t_l_s.html#aa847963eee355eaa6d9054510fb66b65">TLS</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a40526579f289c2f9a91bde432367b54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40526579f289c2f9a91bde432367b54b">&#9670;&nbsp;</a></span>d</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IpcPrivate* d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>pointer to private implementation data of class <a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ipc/src/ipc/<a class="el" href="ipc_8h_source.html">ipc.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevfiipc.html">vfiipc</a></li><li class="navelem"><a class="el" href="classvfiipc_1_1_i_p_c.html">IPC</a></li>
    <li class="footer">Generated on Mon Jun 16 2025 16:04:03 for ADK-Programmers-Guides by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
