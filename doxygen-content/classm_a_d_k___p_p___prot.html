<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADK-Programmers-Guides: mADK_PP_Prot Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="verifone.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="verifonelogo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADK-Programmers-Guides
   &#160;<span id="projectnumber">5.0.3-CD1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classm_a_d_k___p_p___prot.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">mADK_PP_Prot Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="madk__pp__protocol_8h_source.html">madk_pp_protocol.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad77822a0ad67023ae49897b8b80c151d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151d">ProtocolState</a> { <a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151dace7d572a2b50123f5244b47996bd39fc">PS_Stopped</a> = 0, 
<a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151da00205e8fcfd4185829a8a89d5378e547">PS_Running</a> = 1, 
<a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151dae8a4ddbdf955d29d8db6d3a41d2a0512">PS_Aborted</a> = 2
 }</td></tr>
<tr class="separator:ad77822a0ad67023ae49897b8b80c151d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515c365720349ec545c891978cc2256"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a7515c365720349ec545c891978cc2256">AbortState</a> { <a class="el" href="classm_a_d_k___p_p___prot.html#a7515c365720349ec545c891978cc2256a7a73ea105cd0404b571f649aa3f10724">AS_NotAborted</a> = 0, 
<a class="el" href="classm_a_d_k___p_p___prot.html#a7515c365720349ec545c891978cc2256a1f666b5421a566da41f5a5787408639d">AS_AbortIdle</a> = 1, 
<a class="el" href="classm_a_d_k___p_p___prot.html#a7515c365720349ec545c891978cc2256ad8a64a57556eada48fb2e36eb447375c">AS_ConnectionLost</a> = 2
 }</td></tr>
<tr class="separator:a7515c365720349ec545c891978cc2256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698cbe53af5c397dcf4dac14ea8880e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6">CMDActiveType</a> { <a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6ace0044011316cb536586f52643c5472f">CMD_None</a> = 0, 
<a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6ac70c8919d2f46d48b6123c6c92c39cda">CMD_Active</a> = 1, 
<a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6ad4e03ef5b771a349fb6313d95c13a83f">CMD_Nested</a> = 2
 }</td></tr>
<tr class="separator:a698cbe53af5c397dcf4dac14ea8880e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa78a57fb6d6e8185fbfe78a1ff56c200"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structm_a_d_k___p_p___prot___loader.html">mADK_PP_Prot_Loader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#aa78a57fb6d6e8185fbfe78a1ff56c200">loader</a> ()</td></tr>
<tr class="separator:aa78a57fb6d6e8185fbfe78a1ff56c200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671f8a7fd53920c9532b898a8a26f165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a671f8a7fd53920c9532b898a8a26f165">poll</a> (int timeout_msec=-1)</td></tr>
<tr class="separator:a671f8a7fd53920c9532b898a8a26f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e55bafa77bcbdbeda4258ecadd5357"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive</a> (std::vector&lt; unsigned char &gt; &amp;cmd, int timeout_msec=-1)</td></tr>
<tr class="separator:ab2e55bafa77bcbdbeda4258ecadd5357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75017b64297bc5a74260a768fb86cf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ae75017b64297bc5a74260a768fb86cf1">abort</a> ()</td></tr>
<tr class="separator:ae75017b64297bc5a74260a768fb86cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f13b08d59a38adeb5d755179befa6b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a1f13b08d59a38adeb5d755179befa6b8">send</a> (const unsigned char *cmd, unsigned size)</td></tr>
<tr class="separator:a1f13b08d59a38adeb5d755179befa6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bb7ccacd456083681bb2ecafac3d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab7bb7ccacd456083681bb2ecafac3d77">send</a> (const std::vector&lt; unsigned char &gt; &amp;cmd)</td></tr>
<tr class="separator:ab7bb7ccacd456083681bb2ecafac3d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345e47376ab38e76aa77b2bd774b104d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a345e47376ab38e76aa77b2bd774b104d">command</a> (const unsigned char *cmd, unsigned size)</td></tr>
<tr class="separator:a345e47376ab38e76aa77b2bd774b104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1630f914c3dbf9ebc62ad6a5c7f9ebd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a1630f914c3dbf9ebc62ad6a5c7f9ebd9">request</a> (const unsigned char *cmd, unsigned size)</td></tr>
<tr class="separator:a1630f914c3dbf9ebc62ad6a5c7f9ebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addef44d3ee301a4179eb0e143b059024"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#addef44d3ee301a4179eb0e143b059024">request</a> (const std::vector&lt; unsigned char &gt; &amp;cmd)</td></tr>
<tr class="separator:addef44d3ee301a4179eb0e143b059024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb666307a7aa15fc7aae63d454e4394"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a0bb666307a7aa15fc7aae63d454e4394">recv_response</a> (std::vector&lt; unsigned char &gt; &amp;response, int timeout_msec=-1)</td></tr>
<tr class="separator:a0bb666307a7aa15fc7aae63d454e4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f545ea92dfa23883944cf61437cc189"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a5f545ea92dfa23883944cf61437cc189">set_busy</a> (bool flag, bool cmd_ctx=true)</td></tr>
<tr class="separator:a5f545ea92dfa23883944cf61437cc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06933abaabc7a6dcd0b7bd8882efad9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a06933abaabc7a6dcd0b7bd8882efad9f">loadAcl</a> ()</td></tr>
<tr class="separator:a06933abaabc7a6dcd0b7bd8882efad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28b6669bc9832ba7a9ad10765341494"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6">CMDActiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#af28b6669bc9832ba7a9ad10765341494">command_active</a> () const</td></tr>
<tr class="separator:af28b6669bc9832ba7a9ad10765341494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5997aaaa2d622f0ca57f8b24a51a7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#aad5997aaaa2d622f0ca57f8b24a51a7b">start</a> ()</td></tr>
<tr class="separator:aad5997aaaa2d622f0ca57f8b24a51a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c528baf37154d347366083f0f816846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a8c528baf37154d347366083f0f816846">stop</a> ()</td></tr>
<tr class="separator:a8c528baf37154d347366083f0f816846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e00f98394d90b75bc7406dfa4efe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab65e00f98394d90b75bc7406dfa4efe9">setRecoveryMode</a> (bool on_off)</td></tr>
<tr class="separator:ab65e00f98394d90b75bc7406dfa4efe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4649d555fb71b605cda7b61162d030"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151d">ProtocolState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a6d4649d555fb71b605cda7b61162d030">get_protocol_state</a> () const</td></tr>
<tr class="separator:a6d4649d555fb71b605cda7b61162d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fd96bc25e3d509fb54028c2e4b91f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#aa0fd96bc25e3d509fb54028c2e4b91f6">connected</a> () const</td></tr>
<tr class="separator:aa0fd96bc25e3d509fb54028c2e4b91f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa678c3364670ab6f479de87652ada0b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#aa678c3364670ab6f479de87652ada0b4">check_abort</a> () const</td></tr>
<tr class="separator:aa678c3364670ab6f479de87652ada0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390ac45aaaa013d33bcef40d625f142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab390ac45aaaa013d33bcef40d625f142">set_command</a> (void *handle, char *cmd, int size, char protType, unsigned msgId)</td></tr>
<tr class="separator:ab390ac45aaaa013d33bcef40d625f142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab830518e59100970fe386745510590f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab830518e59100970fe386745510590f5">get_status</a> (struct ProtStatus *status) const</td></tr>
<tr class="separator:ab830518e59100970fe386745510590f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e27866e15dfcacd243894c3271e07e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a5e27866e15dfcacd243894c3271e07e7">get_connection_info</a> (struct ConnectInfo *info) const</td></tr>
<tr class="separator:a5e27866e15dfcacd243894c3271e07e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab838213968e74a9456a7eb4dcfc820b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab838213968e74a9456a7eb4dcfc820b6">free_connection_info</a> (struct ConnectInfo *info) const</td></tr>
<tr class="separator:ab838213968e74a9456a7eb4dcfc820b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bbb300025687b2648bf12ea355f428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a66bbb300025687b2648bf12ea355f428">set_com_profile</a> (const char *file) const</td></tr>
<tr class="separator:a66bbb300025687b2648bf12ea355f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd80db538f844114879d9a5868f63aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#afd80db538f844114879d9a5868f63aca">trusted_connection</a> ()</td></tr>
<tr class="separator:afd80db538f844114879d9a5868f63aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67beb232925c781e9e84d7f403c2fbcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a67beb232925c781e9e84d7f403c2fbcb">get_tcp_info</a> (struct TcpInfo *info)</td></tr>
<tr class="separator:a67beb232925c781e9e84d7f403c2fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b3567bd0e3561d3f969e6df82233d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a6e7b3567bd0e3561d3f969e6df82233d">get_uds_info</a> (struct UdsInfo *info)</td></tr>
<tr class="separator:a6e7b3567bd0e3561d3f969e6df82233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ab6dfcd39150866277c10883e3cc1a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ac4ab6dfcd39150866277c10883e3cc1a">get_handle</a> () const</td></tr>
<tr class="separator:ac4ab6dfcd39150866277c10883e3cc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bc09fd8222a3c92e69a59e0ef6b41f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ae0bc09fd8222a3c92e69a59e0ef6b41f">get_protocol_type</a> () const</td></tr>
<tr class="separator:ae0bc09fd8222a3c92e69a59e0ef6b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bd5319e2acc8c8de0b9f1c1395e77c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#aa2bd5319e2acc8c8de0b9f1c1395e77c">isConnectionThread</a> () const</td></tr>
<tr class="separator:aa2bd5319e2acc8c8de0b9f1c1395e77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109345afd11af36903830d8d5e06f75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ab109345afd11af36903830d8d5e06f75">isMainConnectionThread</a> () const</td></tr>
<tr class="separator:ab109345afd11af36903830d8d5e06f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61541e0bea41735419f0db00c75fff3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a61541e0bea41735419f0db00c75fff3e">select</a> (int comInterfaces, char **ComFileName)</td></tr>
<tr class="separator:a61541e0bea41735419f0db00c75fff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6b7b719a059719a202022830931b241b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classm_a_d_k___p_p___prot.html">mADK_PP_Prot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm_a_d_k___p_p___prot.html#a6b7b719a059719a202022830931b241b">getInstance</a> ()</td></tr>
<tr class="separator:a6b7b719a059719a202022830931b241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>wrapper class for SDI protocol (API of lib_mADK_PP_Prot.so) This class allows to create exactly one object instance (singleton). </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7515c365720349ec545c891978cc2256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7515c365720349ec545c891978cc2256">&#9670;&nbsp;</a></span>AbortState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classm_a_d_k___p_p___prot.html#a7515c365720349ec545c891978cc2256">AbortState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7515c365720349ec545c891978cc2256a7a73ea105cd0404b571f649aa3f10724"></a>AS_NotAborted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7515c365720349ec545c891978cc2256a1f666b5421a566da41f5a5787408639d"></a>AS_AbortIdle&#160;</td><td class="fielddoc"><p>no abort was triggered </p>
</td></tr>
<tr><td class="fieldname"><a id="a7515c365720349ec545c891978cc2256ad8a64a57556eada48fb2e36eb447375c"></a>AS_ConnectionLost&#160;</td><td class="fielddoc"><p>abort next call of <a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a> in idle loop </p>
</td></tr>
</table>

</div>
</div>
<a id="a698cbe53af5c397dcf4dac14ea8880e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698cbe53af5c397dcf4dac14ea8880e6">&#9670;&nbsp;</a></span>CMDActiveType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6">CMDActiveType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>type of active command, returned by command_active </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a698cbe53af5c397dcf4dac14ea8880e6ace0044011316cb536586f52643c5472f"></a>CMD_None&#160;</td><td class="fielddoc"><p>no command is active, <a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a> wasn't called </p>
</td></tr>
<tr><td class="fieldname"><a id="a698cbe53af5c397dcf4dac14ea8880e6ac70c8919d2f46d48b6123c6c92c39cda"></a>CMD_Active&#160;</td><td class="fielddoc"><p><a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a> was called and a command is active </p>
</td></tr>
<tr><td class="fieldname"><a id="a698cbe53af5c397dcf4dac14ea8880e6ad4e03ef5b771a349fb6313d95c13a83f"></a>CMD_Nested&#160;</td><td class="fielddoc"><p>a nested command (within a callback) is active </p>
</td></tr>
</table>

</div>
</div>
<a id="ad77822a0ad67023ae49897b8b80c151d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77822a0ad67023ae49897b8b80c151d">&#9670;&nbsp;</a></span>ProtocolState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151d">ProtocolState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad77822a0ad67023ae49897b8b80c151dace7d572a2b50123f5244b47996bd39fc"></a>PS_Stopped&#160;</td><td class="fielddoc"><p>protocol stopped </p>
</td></tr>
<tr><td class="fieldname"><a id="ad77822a0ad67023ae49897b8b80c151da00205e8fcfd4185829a8a89d5378e547"></a>PS_Running&#160;</td><td class="fielddoc"><p>protocol running </p>
</td></tr>
<tr><td class="fieldname"><a id="ad77822a0ad67023ae49897b8b80c151dae8a4ddbdf955d29d8db6d3a41d2a0512"></a>PS_Aborted&#160;</td><td class="fielddoc"><p>protocol aborted by <a class="el" href="classm_a_d_k___p_p___prot.html#a8c528baf37154d347366083f0f816846">stop()</a> function (wait for thread termination) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae75017b64297bc5a74260a768fb86cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75017b64297bc5a74260a768fb86cf1">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the SDI main thread is waiting in idle loop for incomming commands with function <a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a>/poll(), this function can be called from another thread to abort the waiting main thread. If SDI main thread is not idle (e.g. when processing a command), the internal abort flag is set only, which will abort <a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a>/poll() at once, when SDI main thread is idle again. In other words, <a class="el" href="classm_a_d_k___p_p___prot.html#ae75017b64297bc5a74260a768fb86cf1">abort()</a> won't abort <a class="el" href="classm_a_d_k___p_p___prot.html#a0bb666307a7aa15fc7aae63d454e4394">recv_response()</a> used to receive responses or nested SDI commands. It affects the idle loop only. </p><dl class="section return"><dt>Returns</dt><dd>true in case that SDI main thread was idle and reveive()/poll() was aborted immediatelly, else false (abort flag set for pending abort, when SDI gets idle again). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>With successful abort, <a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a>/poll() will return false </dd></dl>

</div>
</div>
<a id="aa678c3364670ab6f479de87652ada0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa678c3364670ab6f479de87652ada0b4">&#9670;&nbsp;</a></span>check_abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool check_abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>check, if the remote device has sent an abort command 20-02 to cancel the urrent active command. </p><dl class="section return"><dt>Returns</dt><dd>true if the device has sent an abort, else false </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This flag is reset when sending the command response with <a class="el" href="classm_a_d_k___p_p___prot.html#a1f13b08d59a38adeb5d755179befa6b8">send()</a>. </dd></dl>

</div>
</div>
<a id="a345e47376ab38e76aa77b2bd774b104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345e47376ab38e76aa77b2bd774b104d">&#9670;&nbsp;</a></span>command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool command </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send a unidirectional command (without receiving a response) over main connection. For commands having a response, please use <a class="el" href="classm_a_d_k___p_p___prot.html#a1630f914c3dbf9ebc62ad6a5c7f9ebd9">request()</a> and <a class="el" href="classm_a_d_k___p_p___prot.html#a0bb666307a7aa15fc7aae63d454e4394">recv_response()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>pointer to command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of command buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if command was passed to protocol, false is returned for: -parameter error -protocol isn't connected to remote device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function always sends the command, disregarding SDI server is recently processing a command or not. </dd>
<dd>
This function is not allowed to be used by SDI side connection threads. </dd></dl>

</div>
</div>
<a id="af28b6669bc9832ba7a9ad10765341494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28b6669bc9832ba7a9ad10765341494">&#9670;&nbsp;</a></span>command_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classm_a_d_k___p_p___prot.html#a698cbe53af5c397dcf4dac14ea8880e6">CMDActiveType</a> command_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SDI server has already called <a class="el" href="classm_a_d_k___p_p___prot.html#ab2e55bafa77bcbdbeda4258ecadd5357">receive()</a> to process a command from main connection and not yet finished this command with call of <a class="el" href="classm_a_d_k___p_p___prot.html#a1f13b08d59a38adeb5d755179befa6b8">send()</a>. return active command type, see enum CMDActiveType </p>

</div>
</div>
<a id="aa0fd96bc25e3d509fb54028c2e4b91f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fd96bc25e3d509fb54028c2e4b91f6">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>check if connection, which belongs to the invoking thread, is still alive. </p><dl class="section return"><dt>Returns</dt><dd>true, if the connection is alive, else false for disturbed connection or if there is no connection, which belongs to the invoking thread </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses <a class="el" href="classm_a_d_k___p_p___prot.html#ac4ab6dfcd39150866277c10883e3cc1a">get_handle()</a> and is allowed to be invoked by both, the SDI main thread and side connection threads </dd></dl>

</div>
</div>
<a id="ab838213968e74a9456a7eb4dcfc820b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab838213968e74a9456a7eb4dcfc820b6">&#9670;&nbsp;</a></span>free_connection_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_connection_info </td>
          <td>(</td>
          <td class="paramtype">struct ConnectInfo *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>free the connection information, see description of mADK_PP_Prot_FreeConnectInfo() </p>

</div>
</div>
<a id="a5e27866e15dfcacd243894c3271e07e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e27866e15dfcacd243894c3271e07e7">&#9670;&nbsp;</a></span>get_connection_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_connection_info </td>
          <td>(</td>
          <td class="paramtype">struct ConnectInfo *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read the connection information, see description of mADK_PP_Prot_GetConnectInfo() </p>

</div>
</div>
<a id="ac4ab6dfcd39150866277c10883e3cc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ab6dfcd39150866277c10883e3cc1a">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * get_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the connection handle, which belongs to the invoking thread. The SDI main thread (and also other application threads) get the handle of the main connection. Side connection threads get the handle of its side connection. </p><dl class="section return"><dt>Returns</dt><dd>connection handle for invoking thread, NULL if there is no active connection. </dd></dl>

</div>
</div>
<a id="a6d4649d555fb71b605cda7b61162d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4649d555fb71b605cda7b61162d030">&#9670;&nbsp;</a></span>get_protocol_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classm_a_d_k___p_p___prot.html#ad77822a0ad67023ae49897b8b80c151d">ProtocolState</a> get_protocol_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return current the state of the protocol (stopped, running, aborted) </p><dl class="section return"><dt>Returns</dt><dd>protocol state, see enum ProtocolState </dd></dl>

</div>
</div>
<a id="ae0bc09fd8222a3c92e69a59e0ef6b41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bc09fd8222a3c92e69a59e0ef6b41f">&#9670;&nbsp;</a></span>get_protocol_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char get_protocol_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the protocol type of the recent command from main connetion or side connection </p><dl class="section return"><dt>Returns</dt><dd>'A', 'B', 'C' or 'D' if a command is active, else 0 </dd></dl>

</div>
</div>
<a id="ab830518e59100970fe386745510590f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab830518e59100970fe386745510590f5">&#9670;&nbsp;</a></span>get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_status </td>
          <td>(</td>
          <td class="paramtype">struct ProtStatus *&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read the protocol status, see description of mADK_PP_Prot_GetStatus() </p>

</div>
</div>
<a id="a67beb232925c781e9e84d7f403c2fbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67beb232925c781e9e84d7f403c2fbcb">&#9670;&nbsp;</a></span>get_tcp_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_tcp_info </td>
          <td>(</td>
          <td class="paramtype">struct TcpInfo *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if connection, which belongs to the invoking thread, is a TCP/IP connection. In this case connection details of the remote TCP/IP client are returned with parameter <code>info</code>. </p><dl class="section return"><dt>Returns</dt><dd>true in case of a TCP/IP connection, else false for error, e.g. the thread serves another type of connection or the connection was already lost. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses <a class="el" href="classm_a_d_k___p_p___prot.html#ac4ab6dfcd39150866277c10883e3cc1a">get_handle()</a> and is allowed to be invoked by both, the SDI main thread and side connection threads. </dd></dl>

</div>
</div>
<a id="a6e7b3567bd0e3561d3f969e6df82233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7b3567bd0e3561d3f969e6df82233d">&#9670;&nbsp;</a></span>get_uds_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_uds_info </td>
          <td>(</td>
          <td class="paramtype">struct UdsInfo *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if connection, which belongs to the invoking thread, is an UDS connection. In this case connection details of the remote UDS client are returned with parameter <code>info</code>. </p><dl class="section return"><dt>Returns</dt><dd>true in case of an UDS connection, else false for error, e.g. the thread servers another type of connection or the connection was already lost. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses <a class="el" href="classm_a_d_k___p_p___prot.html#ac4ab6dfcd39150866277c10883e3cc1a">get_handle()</a> and is allowed to be invoked by both, the SDI main thread and side connection threads. </dd></dl>

</div>
</div>
<a id="a6b7b719a059719a202022830931b241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7b719a059719a202022830931b241b">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classm_a_d_k___p_p___prot.html">mADK_PP_Prot</a> * getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>creates/returns the protocol instance as singleton object </p><dl class="section return"><dt>Returns</dt><dd>pointer to <a class="el" href="classm_a_d_k___p_p___prot.html">mADK_PP_Prot</a> singleton object </dd></dl>

</div>
</div>
<a id="aa2bd5319e2acc8c8de0b9f1c1395e77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bd5319e2acc8c8de0b9f1c1395e77c">&#9670;&nbsp;</a></span>isConnectionThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnectionThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if the calling thread is a protocol thread (not SDI main thread or a sibling of it). This is usually the case if <a class="el" href="main_8cpp.html#a4892e1b795462119ef4d6fa87c860b90">process_side_command()</a> is invoked to process the command as side command asynchronously. </p><dl class="section return"><dt>Returns</dt><dd>true, if the calling thread is a protocol connection thread </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Don't use this function from inside <a class="el" href="classm_a_d_k___p_p___prot.html#ab390ac45aaaa013d33bcef40d625f142">mADK_PP_Prot::set_command()</a>, before the handle was set into <a class="el" href="class_connection_context.html">ConnectionContext</a>. </dd>
<dd>
This function returns also true, if the connection thread caring about the main connection (and usually serving the SDI main thread) invokes this function. Finally, this is correct, since if a type C or D command is received on the main connection, this command must be handled as a side command and the main connection thread must invoke <a class="el" href="main_8cpp.html#a4892e1b795462119ef4d6fa87c860b90">process_side_command()</a> instead of providing the SDI command to the SDI main thread. See also function <a class="el" href="classm_a_d_k___p_p___prot.html#ab109345afd11af36903830d8d5e06f75">isMainConnectionThread()</a> to check, if the connection thread is the thread caring about the main connection </dd></dl>

</div>
</div>
<a id="ab109345afd11af36903830d8d5e06f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab109345afd11af36903830d8d5e06f75">&#9670;&nbsp;</a></span>isMainConnectionThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isMainConnectionThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if the calling thread is a protocol thread, which cares about the main connection, which owns the payment lock. Please note that the function will return false for SDI main thread or a sibling of it. Only a protocol thread usually does asynchronous processing of SDI commands can be the main connection thread. </p><dl class="section return"><dt>Returns</dt><dd>true, if the calling thread is a protocol connection thread, which cares about the main connection. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See also <a class="el" href="classm_a_d_k___p_p___prot.html#aa2bd5319e2acc8c8de0b9f1c1395e77c">isConnectionThread()</a>, which returns true for all protocol connection threads. </dd></dl>

</div>
</div>
<a id="a06933abaabc7a6dcd0b7bd8882efad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06933abaabc7a6dcd0b7bd8882efad9f">&#9670;&nbsp;</a></span>loadAcl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loadAcl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load/Reload Access Control List configurations </p><dl class="section return"><dt>Returns</dt><dd>true on success, otherwise false </dd></dl>

</div>
</div>
<a id="aa78a57fb6d6e8185fbfe78a1ff56c200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78a57fb6d6e8185fbfe78a1ff56c200">&#9670;&nbsp;</a></span>loader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structm_a_d_k___p_p___prot___loader.html">mADK_PP_Prot_Loader</a>* loader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>function to access the library loader from static function mADK_PP_Prot::run() </p><dl class="section return"><dt>Returns</dt><dd>pointer to <a class="el" href="structm_a_d_k___p_p___prot___loader.html">mADK_PP_Prot_Loader</a> object </dd></dl>

</div>
</div>
<a id="a671f8a7fd53920c9532b898a8a26f165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671f8a7fd53920c9532b898a8a26f165">&#9670;&nbsp;</a></span>poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool poll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>poll for an incomming command on main connection </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>wait timeout in milliseconds A negative value means waiting infinite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if a command is available In case of timeout or abort, false is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not allowed to be used by SDI side connection threads. </dd></dl>

</div>
</div>
<a id="ab2e55bafa77bcbdbeda4258ecadd5357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e55bafa77bcbdbeda4258ecadd5357">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool receive </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>receive a new SDI command from main connection </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cmd</td><td>received protocol command (empty vector in case of timeout) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>receive timeout in milliseconds. A negative value means waiting infinite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the command was received successfully. In case of timeout or abort, false is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not allowed to be used by SDI side connection threads. </dd></dl>

</div>
</div>
<a id="a0bb666307a7aa15fc7aae63d454e4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb666307a7aa15fc7aae63d454e4394">&#9670;&nbsp;</a></span>recv_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recv_response </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_msec</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>receive a response on main connection of a pequest previously sent with function <a class="el" href="classm_a_d_k___p_p___prot.html#a1630f914c3dbf9ebc62ad6a5c7f9ebd9">request()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>received request response (empty vector in case of error/timeout) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_msec</td><td>receive timeout in milliseconds. A negative value means waiting infinite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request response was received successfully. false is returned for: -if no reuqest is recently active (parameter response is empty) -receive error or timeout (parameter response is empty) -message received, but no response for the current request (parameter response contains the received command, which might be processed by SDI server as nested command while the current request is active) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not allowed to be used by SDI side connection threads. </dd></dl>

</div>
</div>
<a id="addef44d3ee301a4179eb0e143b059024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addef44d3ee301a4179eb0e143b059024">&#9670;&nbsp;</a></span>request() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool request </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>shortcut for function <a class="el" href="classm_a_d_k___p_p___prot.html#a1630f914c3dbf9ebc62ad6a5c7f9ebd9">request()</a> above using a vector for request command </p>

</div>
</div>
<a id="a1630f914c3dbf9ebc62ad6a5c7f9ebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1630f914c3dbf9ebc62ad6a5c7f9ebd9">&#9670;&nbsp;</a></span>request() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool request </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send a request over main connection. Use <a class="el" href="classm_a_d_k___p_p___prot.html#a0bb666307a7aa15fc7aae63d454e4394">recv_response()</a> afterwards to receive the request response. Recently supported request types are: 91-xx: EMV callbacks (with response 92-xx) 9B-xx: Control callbacks (with response 9C-xx) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>pointer to request buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of request buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request was sent successfully. false is returned for -parameter error -no SDI command is active -another request is already active -request type is not supported (unknown request type) -protocol isn't connected to remote device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not send the request, if no SDI command is active. </dd>
<dd>
This function is not allowed to be used by SDI side connection threads. </dd></dl>

</div>
</div>
<a id="ad20897c5c8bd47f5d4005989bead0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20897c5c8bd47f5d4005989bead0e55">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>reset the protocol. This will close all active connections and lead to invocation of select_cb() to read new COM settings including COM setup </p>

</div>
</div>
<a id="a61541e0bea41735419f0db00c75fff3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61541e0bea41735419f0db00c75fff3e">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comInterfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ComFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>used by select_cb() to select the COM profile for the protocol </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comInterfaces</td><td>bitmask of supported COM interfaces (see ADKCOM property COM_PROP_SUPP_INTERFACES) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ComFileName</td><td>new ADKCOM communication profile to be used (C-string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is intented for protocol thread only and must not be used from SDI server directly! </dd></dl>

</div>
</div>
<a id="ab7bb7ccacd456083681bb2ecafac3d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bb7ccacd456083681bb2ecafac3d77">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool send </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>shortcut for function <a class="el" href="classm_a_d_k___p_p___prot.html#a1f13b08d59a38adeb5d755179befa6b8">send()</a> above using a vector </p>

</div>
</div>
<a id="a1f13b08d59a38adeb5d755179befa6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f13b08d59a38adeb5d755179befa6b8">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool send </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>send a command response </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>pointer to command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of command buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the command was passed to protocol, false is returned for: -parameter error -no command active -protocol isn't connected to remote device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not send the response for main connection, if no command is active. </dd>
<dd>
Function is allowed to be used from a SDI side connection thread, which has the same effect as the invocation of _send(). </dd></dl>

</div>
</div>
<a id="a5f545ea92dfa23883944cf61437cc189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f545ea92dfa23883944cf61437cc189">&#9670;&nbsp;</a></span>set_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_busy </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cmd_ctx</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set SDI server busy and decline incoming commands with busy response. This is required to get an exclusive lock to decline incoming SDI commands. The lock is applied to both, main connection (type A/B/D) and side connections (type C/D). The type of lock depends on the context from which the function is invoked:</p><ul>
<li>Set <code>cmd_ctx</code> to true (default) if the function is used during processing of an active command, which will set SDI server out of order for a specific time, e.g. a command for a SW update. During duration of this command, SDI server will decline commands on other connections. Only this connection, which belongs to the invoking thread, is able to process further commands.</li>
<li>Set <code>cmd_ctx</code> to false, if this function is used out of a command context, e.g. when entering the UI menu to block all connections and to disallow command processing basically. <dl class="section note"><dt>Note</dt><dd>In the case that another SDI command (type A/B/C/D) is pending or already processed, the exclusive lock is not obtained and the function returns false. The function will return true, if it is invoked at twice to obtain the lock, in this case one function call is required to release the lock again (no recursive locking possible). </dd>
<dd>
This function uses <a class="el" href="classm_a_d_k___p_p___prot.html#ac4ab6dfcd39150866277c10883e3cc1a">get_handle()</a> and is allowed to be invoked by both, the SDI main thread and side connection threads. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>set to true to obtain the exclusive lock to set SDI server busy. Reset with false to unlock SDI server to accept new commands again, in this case the function return value is always true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd_ctx</td><td>set to true, if function is invoked during an active SDI command, set to false for cases to block all connections (e.g. to enter menu). This parameter is ignored, if <code>flag</code> is set to false to release the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for success, else false (in case that other SDI commands are pending or processed) </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a66bbb300025687b2648bf12ea355f428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bbb300025687b2648bf12ea355f428">&#9670;&nbsp;</a></span>set_com_profile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_com_profile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set/switch to a new ADKCOM profile, see description of mADK_PP_Prot_SelectComProfile() </p>

</div>
</div>
<a id="ab390ac45aaaa013d33bcef40d625f142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390ac45aaaa013d33bcef40d625f142">&#9670;&nbsp;</a></span>set_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_command </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>protType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>msgId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>used by command_callback() to take over the recent received command for processing </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>session handle used to indetify connection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>pointer to command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the command buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protType</td><td>protocol type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgId</td><td>message ID from protocol header type 'D' (or 0, if <em>protType</em> is not 'D') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is intented for protocol thread only and must not be used from SDI server directly! </dd></dl>

</div>
</div>
<a id="ab65e00f98394d90b75bc7406dfa4efe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65e00f98394d90b75bc7406dfa4efe9">&#9670;&nbsp;</a></span>setRecoveryMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRecoveryMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>activate / deactivate recovery mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_off</td><td>switch recovery mode on or off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad5997aaaa2d622f0ca57f8b24a51a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5997aaaa2d622f0ca57f8b24a51a7b">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>start (or restart) the protocol (if not running yet or if it was stopped) </p><dl class="section return"><dt>Returns</dt><dd>true if the protocol was started or is already running, false for error, if the protocol couldn't be started. </dd></dl>

</div>
</div>
<a id="a8c528baf37154d347366083f0f816846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c528baf37154d347366083f0f816846">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stop the running protocol. </p><dl class="section note"><dt>Note</dt><dd>This function block until the protocol thread terminates. It does nothing, if the protocol wasn't started or already stopped. </dd></dl>

</div>
</div>
<a id="afd80db538f844114879d9a5868f63aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd80db538f844114879d9a5868f63aca">&#9670;&nbsp;</a></span>trusted_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trusted_connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if connection, which belongs to the invoking thread, is a local (trusted) connection. </p><dl class="section return"><dt>Returns</dt><dd>true, if the connection is a local (trusted) connection </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses <a class="el" href="classm_a_d_k___p_p___prot.html#ac4ab6dfcd39150866277c10883e3cc1a">get_handle()</a> and is allowed to be invoked by both, the SDI main thread and side connection threads. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sdi/src/<a class="el" href="madk__pp__protocol_8h_source.html">madk_pp_protocol.h</a></li>
<li>sdi/src/<a class="el" href="madk__pp__protocol_8cpp.html">madk_pp_protocol.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classm_a_d_k___p_p___prot.html">mADK_PP_Prot</a></li>
    <li class="footer">Generated on Mon Jun 16 2025 16:04:03 for ADK-Programmers-Guides by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
