<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADK-Programmers-Guides: VeriShield Security Scripts (VSS)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="verifone.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="verifonelogo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADK-Programmers-Guides
   &#160;<span id="projectnumber">5.0.3-CD1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vss_documentation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">VeriShield Security Scripts (VSS) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="vss_documentation"></a>
VeriShield Security Scripts (VSS)</h1>
<h1><a class="anchor" id="sec_vss_introduction"></a>
Introduction</h1>
<h2><a class="anchor" id="subsec_vss_purpose"></a>
Purpose</h2>
<p>This document is to describe VeriShield Security Scripts (VSS), a system that provides security modules with enough flexibility to support different key management schemes, such as triple-DES for master and session keys, offline PIN verifications, Australian AS2806 part 6, Canadian Interac, Semp/4B, and APACS40. This document applies to security modules that implement VSS in programmable and non-programmable devices.</p>
<h2><a class="anchor" id="subsec_vss_organization"></a>
Organization</h2>
<p>This guide is organized as follows:</p><ul>
<li><a class="el" href="vss_documentation.html#sec_vss_overview">General Overview</a>. Provides an overview of the VeriShield Security Scripts.</li>
<li><a class="el" href="vss_documentation.html#sec_vss_write">Write a Security Script</a>. Describes the principles, keywords, instructions and macrocommands used to create a Security Script.</li>
<li><a class="el" href="vss_documentation.html#sec_vss_macro_command_execution">Macro Command Execution</a>. Explains how the macro scripts of PINpads and terminals are executed.</li>
<li><a class="el" href="vss_documentation.html#sec_vss_tools">Tools</a>. Discusses the tools such as the Script Processor, Signing Tool and the Key Loading tools used in PINpads and terminals.</li>
<li><a class="el" href="vss_documentation.html#sec_vss_loading_apis">VSS Key Installation APIs</a>. Describes the APIs available to install VSS keys.</li>
<li><a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>, Displays the opcode table,which identifies the opcode value for all the keywords that might generate an execution error.</li>
<li><a class="el" href="vss_documentation.html#sec_vss_appendix_b">Appendix B: VSS Troubleshooting Guide</a>. Describes frequent VSS issues and how to resolve them</li>
</ul>
<p>To learn more about the VeriShield Security Scripts please refer to the following documents and their associated Verifone Part Numbers (VPN): <br  />
 <em> [Ref 3] - SPRD - SC552 Croatia - Revision 1.3<br  />
 VDN 06199 - PINpad 1000 Plus – Technical Specification Document<br  />
 VDN 15299 - Generic Personalization I for Mars V1 - Technical Specifications<br  />
 VDN 15471 - Most Commonly Used PIN Blocks<br  />
 VDN 19322 - Secure Macros for PEDguard Internal PINpad<br  />
 </em></p>
<h1><a class="anchor" id="sec_vss_overview"></a>
Overview</h1>
<p>In the default configurations, the most Verifone PINpads and terminals support only two key management schemes: DUKPT and Master/Session. The two schemes meet the needs of most of the customers and as they are hard-coded, customizing the security module is not required.</p>
<p>For customers who need more flexibility, the VeriShield Security Script mechanism provides support for: Different key management schemes.</p><ul>
<li>Different PIN block formats such as PVV, CVV IBM3624.</li>
<li>Additional key space.</li>
<li>Different encryption algorithms such as triple-DES, AES, RSA. All the information is written in a Security Script file (ASCII) using a VSS extension. This script is processed by a PC tool and converted into a downloadable binary file with a VSO extension. The download is protected by the VeriShield File Authentication (FA) module. Therefore, the Security Script file should be downloaded along with its signature file generated by the VeriShield File Signature Tool (FST).</li>
</ul>
<p><br  />
 </p><div class="image">
<img src="security_script_process.png" alt=""/>
<div class="caption">
Figure 1 Security Script Process</div></div>
<p> <br  />
</p>
<p>The certificate used for FA must have VeriShield Security Scripts enabled for the GID in which the script is loaded. VeriShield Security Scripts have a special flag in the certificate for each GID. So, if a sponsor certificate is loaded and a secure script is to be loaded, it can only go into a GID permitting script.</p>
<p>Writing the script does not require any specific development environment besides the script processor tool. Application development teams will develop the scripts. The Sponsor of the PINpad will have the responsibility of auditing and signing the Security Script. Two documents should always come along with a Security Script. The first one is the support document for the security audit. The second one is the user’s manual for the application developers.</p>
<p>Up to eight, 64 for VSS v5.0 and higher, 96 for VSS v8.0 and higher, 192 for VSS v9.0 and higher Security Scripts can be installed in the target unit at the same time. Each script defines its independent key space and whether or not those keys can be loaded using the generic key loading functions <code>iPS_LoadMasterClearKey()</code> and <code>iPS_LoadMasterEncKey()</code>. When using those generic functions, the loading of keys in the clear must be done in a unique session, because all the keys loaded in the previous session are erased. If the generic functions are not used, then the Security Script must define specific macro commands dedicated to the key loading.</p>
<p>The Security Script commands are based on the concept called SMCL (Security Module Control Language) used in SC5xx PINpad in Sweden, Germany, Poland, etc. The idea is to have flexibility inside the security module without compromising the security. The PINpad provides a small interpreter that is used to:</p><ul>
<li>Handle the key derivation process for a transaction.</li>
<li>Handle the key exchange process (store a key after decrypting it with another key).</li>
<li>Handle the PIN encryption process to account for different algorithms.</li>
<li>Provide enough support to handle specific key management schemes.</li>
</ul>
<p>The main difference with the SMCL is that the Security Script commands are protected by VeriShield instead of the secure commands, as we know them in the SC5xx PINpads. In PINpads and terminals, the whole set of commands are signed and downloaded into the PINpad before deployment, whereas SMCL commands are individually signed and sent to the security module at the time of execution.</p>
<p>Each Security Script macro command is a group of elementary operations that cannot be executed individually for security reasons. A chaining mechanism can be used to force the execution of the macros in a pre-defined sequence. This can be useful to ensure the key separation and key hierarchy, for instance, enforcing successive derivations of a key before usage or preventing key misusage when a same block can hold different type of keys(MAC key, PIN key, PVV key, etc.). Generally, the macros will perform operations at a level high enough that no chaining should be necessary.</p>
<h1><a class="anchor" id="sec_vss_write"></a>
Write a Security Script</h1>
<p>This section describes the principles, keywords, instructions and macro commands used to create a Security Script.</p>
<h2><a class="anchor" id="subsec_vss_principle"></a>
Principle</h2>
<p>The Security Script is written using a predefined set of keywords that will be processed by the PC tool.</p>
<p>The script contains three sections:</p>
<ul>
<li>The configuration section that contains the identifier and the name of the script and optional restrictions on some of the generic key management functions of the PINpad/terminal API. For instance, the script can disable the default Master/ Session mode or DUKPT modes in order to implement a specific key management scheme that must not co-exist with the default ones.</li>
<li>The block definition that section defines the number of 8-byte blocks required for the Security Script to run. It also indicates which of those can be loaded using the default master key loading functions. The actual allocation in memory occurs when the script is downloaded in the PINpad. You can also specify a default value for each block (default key or default password). The value is written in the block right after the block allocation in memory during the script loading process. <dl class="section note"><dt>Note</dt><dd>Since the script file is not encrypted, there are serious security concerns: This feature is provided to anticipate specific requests but should not be used.</dd></dl>
</li>
<li>The macro definition section contains the macro command implementation. The Security Script macro commands provide high-level functionality by executing a sequence of low-level sensitive cryptographic operations. At the macro command level, the functionality must be high enough that any misuse of a command does not compromise the security of the system or the customer's PIN. The macro commands can be chained using the mechanism inherited from the SC5xx PINpads' secure commands.</li>
</ul>
<p>Here is a description of the memory available and accessible using the VSS:</p><ul>
<li>255 8-byte locations for key/password/data storage</li>
<li>working registers (A, B0, B1) (8-byte long)</li>
<li>1 current key location (CK) used for DES/AES computations (32-byte long)</li>
<li>1 initialization vector for DES/AES operations in CBC mode (16-byte long)</li>
<li>1 single byte index register (X)</li>
<li>1 521-byte communication buffer (CB)</li>
<li>1 521-byte working buffer (W) used for RSA computations</li>
<li>1 20-byte SHA-1 buffer for storage purpose</li>
</ul>
<p><br  />
 </p><div class="image">
<img src="general_overwiew_of_the_security_script_engine.png" alt=""/>
<div class="caption">
Figure 2 General Overview of the Security Script Engine</div></div>
<p> <br  />
 <br  />
 </p><div class="image">
<img src="additional_op_codes_for_rsa_and_sha_support.png" alt=""/>
<div class="caption">
Figure 3 Additional OP Codes for RSA and SHA Support</div></div>
<p> <br  />
</p>
<p>Register A is the center of the cryptographic engine. Only A (and W for RSA/SHA operations) can exchange data with the communication buffer, block locations and temporary registers B0 and B1. All logical operations and algorithm computations are performed on A. X is a single byte index register used as a pointer on a block location. B0 and B1 are used for storing temporary values. Registers A, B0, B1, CK and X are erased at the end of each macro execution. If a current key needs to be retained, then it must be stored into a block location. The Initialization vector (IV) is retained between the two macro executions.</p>
<h2><a class="anchor" id="subsec_vss_list_of_keywords"></a>
List of Keywords</h2>
<p>Here is the list of keywords and commands available for writing a script.</p>
<a class="anchor" id="multi_row1"></a>
<table class="doxtable">
<caption style="text-align:left">Table 1 Configuration Section</caption>
<tr>
<th>Mnemonic </th><th>Description </th></tr>
<tr>
<td>SUBDEV ID </td><td>Script Identifier, i.e. <br  />
 sub-device number (0 to 7) or <br  />
 (0 to 63) in VSS version 5.0 and higher or <br  />
 (0 to 95) in VSS version 8.0 and higher or <br  />
 (0 to 191) in VSS version 9.0 and higher. <br  />
 The macro commands defined in this script will be executed by calling the ExecuteScript(id,…) function. </td></tr>
<tr>
<td>SCRIPT name </td><td>Script Name must be 8 ASCII char long. This name will then be returned by the GetScriptStatus() function. </td></tr>
<tr>
<td>PP1000_OFF </td><td>Ignored. </td></tr>
<tr>
<td>MS_OFF </td><td>Disable default Master/Session support functions (GP1-like). Used in SC 5000. Ignored in Vx terminals. </td></tr>
<tr>
<td>DUKPT_OFF </td><td>Disable default DUKPT support functions. Used in SC 5000. Ignored in Vx terminals. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row2"></a>
<table class="doxtable">
<caption style="text-align:left">Table 2 Key Definition Section</caption>
<tr>
<th>Mnemonic </th><th>Description </th></tr>
<tr>
<td>DEF_BLK </td><td>Allocate total Nb blocks when loading the script. Only the blocks. </td></tr>
<tr>
<td>totalNb </td><td>From <code>#0</code> to <code>#(loadableNb-1)</code> can be loaded using the default key. </td></tr>
<tr>
<td>loadableNb </td><td>Loading functions. </td></tr>
<tr>
<td>RETAIN_BLK </td><td>Does not erase the block values when upgrading a script. For v6.0 and higher- can also use fixed retain block value of ASCII Hex value of the name of the previous script. This requires. </td></tr>
<tr>
<td>code </td><td>Presentation of a code=DES [KLK xor (NAME|NAME)](NAME) where NAME is the name of the previous script (see keyword SCRIPT). </td></tr>
<tr>
<td>LD_BLK index</td><td>Load a default value into the block <code>#index</code> when installing the script. </td></tr>
<tr>
<td>value </td><td>In the unit. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row3"></a>
<table class="doxtable">
<caption style="text-align:left">Table 3 Macro Definition Section</caption>
<tr>
<th>Mnemonic </th><th>Description </th></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Entry point &amp; initial tests</b> </td></tr>
<tr>
<td>MACRO number </td><td>Define a macro command (entry point) </td></tr>
<tr>
<td>SID curr next err </td><td>Define the State Identifiers used for the chaining mechanism (current to be tested, next if execution is successful and error if execution fails) </td></tr>
<tr>
<td>LENGTH nb </td><td>Test the length of the input data received in the communication buffer (CB) </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Input/Output operations</b> </td></tr>
<tr>
<td>GETA offset </td><td>Copy 8 byte from CB+offset into A </td></tr>
<tr>
<td colspan="2"><em>OP codes labeled (v2.0+) are only available in version 2.0 of the VSS interpreterand higher. <br  />
 OP codes labeled (v4.0+) are only available in version 4.0 of the VSS interpreterand higher.</em> </td></tr>
<tr>
<td>GETA_HA_TO_BIN offset (v2.0) </td><td>Copy 16 bytes from CB+offset, convert from Hex ASCII (‘0’-‘9’, ‘A’-‘F’, ‘a’-‘f’) to Binary and put 8 bytes into A </td></tr>
<tr>
<td>SENDA offset </td><td>Copy A into CB+offset </td></tr>
<tr>
<td>SENDA_BIN_TO_HA offset (v2.0+) </td><td>Copy A, convert from Binary to Hex ASCII (‘0’-‘9’, ‘A’-‘F’), and put 16 bytes into CB+offset </td></tr>
<tr>
<td>GETX offset </td><td>Copy 1 byte from address CB+offset into index register X </td></tr>
<tr>
<td>GETX_HA_TO_BIN offset (v2.0+) </td><td>Copy 2 bytes from address CB+offset, convert from Hex ASCII (‘0’-‘9’, ‘A’-‘F’, ‘a’-‘f’) to Binary, and put 1 byte into index register X </td></tr>
<tr>
<td>SENDX offset </td><td>Copy index register X at address CB+offset </td></tr>
<tr>
<td>SENDX_BIN_TO_HA offset (v2.0+) </td><td>Copy index register X, convert from Binary to Hex ASCII (‘0’-‘9’, ‘A’-‘F’), and put 2 bytes into CB+offset </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Index Register Handling</b> </td></tr>
<tr>
<td>INCX </td><td>Increment index register X </td></tr>
<tr>
<td>DECX </td><td>Decrement index register X </td></tr>
<tr>
<td>ADDXI value </td><td>Add immediate value to index register X </td></tr>
<tr>
<td>LDXI value </td><td>Load index register X with an immediate value </td></tr>
<tr>
<td>MOV_A_X </td><td>Copy the first byte of register A into index register X </td></tr>
<tr>
<td>MOV_X_A </td><td>Copy the content of index register X into first byte of register A </td></tr>
<tr>
<td>TSTXI min max </td><td>Verify that X is in the range [min..max], exit on error if it fails </td></tr>
<tr>
<td>TSTXI_BOR min max Label (v2.0+)</td><td>Verify that X is in the range [min..max], branch to Label if out of range </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>8-bytes register handling</b> </td></tr>
<tr>
<td>CLRA </td><td>Clear register A to all 0x00 </td></tr>
<tr>
<td>SETA </td><td>Set register A to all 0xFF </td></tr>
<tr>
<td>RNDA </td><td>Get a random number into A </td></tr>
<tr>
<td>LDAI value </td><td>Load A with an 8-byte immediate value (mask, variant…) </td></tr>
<tr>
<td>MOV_A_B0 </td><td>Copy A -&gt; B0 </td></tr>
<tr>
<td>MOV_A_B1 </td><td>Copy A -&gt; B1 </td></tr>
<tr>
<td>MOV_B0_A </td><td>Copy B0 -&gt; A </td></tr>
<tr>
<td>MOV_B1_A </td><td>Copy B1 -&gt; A </td></tr>
<tr>
<td>MOV_A_IV </td><td>Copy A -&gt; IV (Set A as IV) </td></tr>
<tr>
<td>MOV_IV_A </td><td>Copy IV -&gt; A (Get the IV into A) </td></tr>
<tr>
<td>CLRIV </td><td>Clear the Initialization Vector (Copy 0 -&gt; IV) </td></tr>
<tr>
<td>SELECTA </td><td>Select A as current key (Copy A -&gt; CK) </td></tr>
<tr>
<td>SELECT index </td><td>Select key <code>#index</code> as current key (Copy key <code>#index</code> -&gt; CK) </td></tr>
<tr>
<td colspan="2"><em>OP codes labeled (v2.0+) are only available in version 2.0 of the VSS interpreter and higher. <br  />
 OP codes labeled (v4.0+) are only available in version 4.0 of the VSS interpreter and higher.</em> </td></tr>
<tr>
<td>SELECTX </td><td>Select key pointed by register X as current key (Copy key <code>#*X</code> -&gt; CK) </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Block handling (storage)</b> </td></tr>
<tr>
<td>STA index </td><td>Copy A -&gt; Slot <code>#index</code> </td></tr>
<tr>
<td>STAX </td><td>Copy the content of register A into the slot pointed by register X </td></tr>
<tr>
<td>LDA index </td><td>Copy Slot <code>#index</code> -&gt; A </td></tr>
<tr>
<td>LDAX </td><td>Copy the content of slot pointed by register X into register A </td></tr>
<tr>
<td>DELETE from to </td><td>Invalidate Slots from <code>#from</code> to <code>#to</code> </td></tr>
<tr>
<td>DELETEX </td><td>Invalidate the Slot pointed by register X </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Logical operations</b> </td></tr>
<tr>
<td>XORA_By </td><td>XOR A with B0/1, result in A </td></tr>
<tr>
<td>ANDA_By </td><td>AND A with B0/1, result in A </td></tr>
<tr>
<td>ORA_By </td><td>OR A with B0/1, result in A </td></tr>
<tr>
<td>LSLA nb </td><td>Logical shift left A (nb bits) </td></tr>
<tr>
<td>LSRA nb </td><td>Logical shift right A (nb bits) </td></tr>
<tr>
<td>COMA </td><td>Complement A </td></tr>
<tr>
<td>INCA </td><td>Increment register A </td></tr>
<tr>
<td>DECA </td><td>Decrement register A </td></tr>
<tr>
<td>ADJ_EVEN </td><td>Adjust the parity of every byte in register A to be even. </td></tr>
<tr>
<td>ADJ_ODD </td><td>Adjust the parity of every byte in register A to be odd. </td></tr>
<tr>
<td>CHK_EVEN </td><td>Check that the parity of every byte in register A is even, exit on error if it fails </td></tr>
<tr>
<td>CHK_EVEN_BNE Label (v2.0+) </td><td>Check that the parity of every byte in register A is even, if not, branch to Label </td></tr>
<tr>
<td>CHK_ODD </td><td>Check that the parity of every byte in register A is odd, exit on error if it fails </td></tr>
<tr>
<td>CHK_ODD_BNO Label (v2.0+) </td><td>Check that the parity of every byte in register A is odd, if not, branch to Label </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Comparisons</b> </td></tr>
<tr>
<td>CMPA_By </td><td>Compare A with register B0/1, exit on error if it fails </td></tr>
<tr>
<td>CMPA_By_BEQ Label (v2.0+) </td><td>Compare A with register B0/1, if A = By, branch to Label </td></tr>
<tr>
<td>CMPA_By_BNE Label (v2.0+) </td><td>Compare A with register B0/1, if A != By, branch to Label </td></tr>
<tr>
<td>CMPA_By_BGT Label (v2.0+) </td><td>Unsigned compare A with register B0/1, if A &gt; By, branch to Label </td></tr>
<tr>
<td>CMPA_By_BLT Label (v2.0+) </td><td>Unsigned compare A with register B0/1, if A &lt; By, branch to Label </td></tr>
<tr>
<td colspan="2"><em>OP codes labeled (v2.0+) are only available in version 2.0 of the VSS interpreter and higher.<br  />
 OP codes labeled (v4.0+) are only available in version 4.0 of the VSS interpreter and higher. </em> </td></tr>
<tr>
<td>CMPA_By_BGE Label (v2.0+) </td><td>Unsigned compare A with register B0/1, if A &gt;= By, branch to Label </td></tr>
<tr>
<td>CMPA_By_BLE Label (v2.0+) </td><td>Unsigned compare A with register B0/1, if A &lt;= By, branch to Label </td></tr>
<tr>
<td>CMPA index </td><td>Compare A with Slot <code>#index</code>, exit on error if it fails </td></tr>
<tr>
<td>CMPA_BEQ index Label (v2.0+) </td><td>Compare A with Slot <code>#index</code>, if A = Slot <code>#index</code>, branch to Label </td></tr>
<tr>
<td>CMPA_BNE index Label (v2.0+) </td><td>Compare A with Slot <code>#index</code>, if A != Slot <code>#index</code>, branch to Label </td></tr>
<tr>
<td>CMPA_BGT index Label (v2.0+) </td><td>Unsigned compare A with Slot <code>#index</code>, if A &gt; Slot <code>#index</code>, branch to Label </td></tr>
<tr>
<td>CMPA_BLT index Label (v2.0+) </td><td>Unsigned compare A with Slot <code>#index</code>, if A &lt; Slot <code>#index</code>, branch to Label </td></tr>
<tr>
<td>CMPA_BGE index Label (v2.0+) </td><td>Unsigned compare A with Slot <code>#index</code>, if A &gt;= Slot <code>#index</code>, branch to Label </td></tr>
<tr>
<td>CMPA_BLE index Label (v2.0+) </td><td>Unsigned compare A with Slot <code>#index</code>, if A &lt;= Slot <code>#index</code>, branch to Label </td></tr>
<tr>
<td>CMPAX </td><td>Compare A with Slot pointed by register X, exit on error if it fails </td></tr>
<tr>
<td>CMPAX_BEQ Label (v2.0+) </td><td>Compare A with Slot pointed by register X, if A = Slot pointed by register X, branch to Label </td></tr>
<tr>
<td>CMPAX_BNE Label (v2.0+) </td><td>Compare A with Slot pointed by register X, if A != Slot pointed by register X, branch to Label </td></tr>
<tr>
<td>CMPAX_BGT Label (v2.0+) </td><td>Unsigned compare A with Slot pointed by register X, if A &gt; Slot pointed by register X, branch to Label </td></tr>
<tr>
<td>CMPAX_BLT Label (v2.0+) </td><td>Unsigned compare A with Slot pointed by register X, if A &lt; Slot pointed by register X, branch to Label </td></tr>
<tr>
<td>CMPAX_BGE Label (v2.0+) </td><td>Unsigned compare A with Slot pointed by register X, if A &gt;= Slot pointed by register X, branch to Label </td></tr>
<tr>
<td>CMPAX_BLE Label (v2.0+) </td><td>Unsigned compare A with Slot pointed by register X, if A &lt;= Slot pointed by register X, branch to Label </td></tr>
<tr>
<td>BRA Label (v2.0+) </td><td>Branch to Label </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>DES/AES operations</b> </td></tr>
<tr>
<td>ALGO_name </td><td>Select the algorithm for the following computations. <br  />
 ALGO_name can take the values DES56, DES112, DES168, AES128, AES192, AES256. </td></tr>
<tr>
<td>EECB </td><td>Encrypt (ECB) A with CK, result in A </td></tr>
<tr>
<td>DECB </td><td>Decrypt (ECB) A with CK, result in A </td></tr>
<tr>
<td>ECBC </td><td>Encrypt (CBC) A with CK, result in A </td></tr>
<tr>
<td>DCBC </td><td>Decrypt (CBC) A with CK result in A </td></tr>
<tr>
<td>EECB_CB offset length (v6.0+) </td><td>Encrypt ECB, communication buffer starting at offset for length. </td></tr>
<tr>
<td>EECB_CB_X offset (v6.0+) </td><td>Encrypt ECB, communication buffer starting at offset for length in X. </td></tr>
<tr>
<td>DECB_CB offset length (v6.0+) </td><td>Decrypt ECB, communication buffer starting at offset for length. </td></tr>
<tr>
<td>DECB_CB_X offset (v6.0+) </td><td>Decrypt ECB, communication buffer starting at offset for length in X. </td></tr>
<tr>
<td>ECBC_CB offset length (v6.0+) </td><td>Encrypt CBC, communication buffer starting at offset for length. </td></tr>
<tr>
<td>ECBC_CB_X offset (v6.0+) </td><td>Encrypt CBC, communication buffer starting at offset for length in X. </td></tr>
<tr>
<td>DCBC_CB offset length (v6.0+) </td><td>Decrypt CBC, communication buffer starting at offset for length. </td></tr>
<tr>
<td>DCBC_CB_X offset (v6.0+) </td><td>Decrypt CBC, communication buffer starting at offset for length in X. </td></tr>
<tr>
<td></td><td>Must clear IV before starting encryption/decryption for CBC.<br  />
 Length must be a multiple of 8 bytes for DES and 16 bytes for AES, so data must be padded.<br  />
 Must select algorithm and then key before execution of OP code.<br  />
 Result in communication buffer. </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>PIN handling commands</b> </td></tr>
<tr>
<td colspan="2"><em>OP codes labeled (v2.0+) are only available in version 2.0 of the VSS interpreter and higher.<br  />
 OP codes labeled (v4.0+) are only available in version 4.0 of the VSS interpreter and higher.</em> </td></tr>
<tr>
<td>GETPINNB </td><td>Get the number of PIN digits into the first (left) byte of A </td></tr>
<tr>
<td>GETPIN0 </td><td>Get PIN into A (from the left) - 1 nibble per digit </td></tr>
<tr>
<td>GETPIN1 </td><td>Get PIN into A (from the right) - 1 nibble per digit </td></tr>
<tr>
<td>GETPIN2 </td><td>Get PIN into A in ASCII - 1 byte at a time </td></tr>
<tr>
<td>GETPIN3 </td><td>Get PIN into A in “Smart card” format </td></tr>
<tr>
<td>DECIM0 </td><td>Decimalization type 0 (PVV &amp; PAC Shell type) </td></tr>
<tr>
<td>DECIM1 </td><td>Decimalization type 1 (IBM3624Offset type) </td></tr>
<tr>
<td>DECIM2 </td><td>Decimalization type 2 (CCV type) </td></tr>
<tr>
<td>OFFSET0 </td><td>Offset function type 0 (A -B0 mod 10 -&gt; A) </td></tr>
<tr>
<td>OFFSET1 </td><td>Offset function type 1 (CCV type 1) </td></tr>
<tr>
<td>OFFSET2 </td><td>Offset function type 2 (CCV type 2) </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>SHA/RSA Operations</b> </td></tr>
<tr>
<td>CMPSHA </td><td>Compare 20 bytes from W with SHA register </td></tr>
<tr>
<td>CMPSHA_BEQ Label (v2.0+) </td><td>Compare 20 bytes from W with SHA register, if W = SHA, branch to Label </td></tr>
<tr>
<td>CMPSHA_BNE Label (v2.0+) </td><td>Compare 20 bytes from W with SHA register, if W != SHA, branch to Label </td></tr>
<tr>
<td>CMPSHA256 (v6.0+) </td><td>Compare 32 bytes from W with SHA register </td></tr>
<tr>
<td>CMPSHA256_BEQ Label (v6.0+) </td><td>Compare 32 bytes from W with SHA register, if W = SHA, branch to Label </td></tr>
<tr>
<td>CMPSHA256_BNE Label (v6.0+) </td><td>Compare 32 bytes from W with SHA register, if W != SHA, branch to Label </td></tr>
<tr>
<td>GETW offset len </td><td>Copy len bytes from CB+offset into W </td></tr>
<tr>
<td>GETW_HA_TO_BIN offset len (v2.0+)</td><td>Copy len (must be even) bytes from CB+offset, convert from Hex ASCII (‘0’-‘9’, ‘A’-‘F’, ‘a’-‘f’) to Binary, and put len/2 bytes into W </td></tr>
<tr>
<td>MOV_A_W </td><td>Copy 8 bytes from A into W </td></tr>
<tr>
<td>MOV_W_A </td><td>Copy 8 bytes from W into A register </td></tr>
<tr>
<td>RNDW (v2.0+) </td><td>Fill W with random data </td></tr>
<tr>
<td>RSACOMP </td><td>Perform RSA computation on data in working buffer (W), result in working buffer (W) </td></tr>
<tr>
<td>SELRSA index </td><td>Select an RSA key for the next computation (0 to 3) </td></tr>
<tr>
<td>SELRSAX </td><td>Select the RSA key pointed by the content of register X. </td></tr>
<tr>
<td>SENDW offset len </td><td>Copy len bytes from W into CB+offset </td></tr>
<tr>
<td>SENDW_BIN_TO_HA offset len (v2.0+)</td><td>Copy len bytes from W, convert from Binary to Hex ASCII (‘ ‘9’, ‘A’-‘F’), and put len*2 bytes into CB+offset </td></tr>
<tr>
<td>SHA256INIT (v6.0+) </td><td>Initialize SHA context for upcoming computation </td></tr>
<tr>
<td>SHA256TERM (v6.0+) </td><td>Get SHA result into W </td></tr>
<tr>
<td>SHA256UPDATE len (v6.0+) </td><td>Compute (SHA) len bytes from W </td></tr>
<tr>
<td>SHAINIT </td><td>Initialize SHA context for upcoming computation </td></tr>
<tr>
<td>SHATERM </td><td>Get SHA result into W </td></tr>
<tr>
<td>SHAUPDATE len </td><td>Compute (SHA) len bytes from W </td></tr>
<tr>
<td>STRSA index </td><td>Copy RSA key from W into slot <code>#index</code> (0 to 3) </td></tr>
<tr>
<td>STRSAX </td><td>Copy RSA key from W into the slot pointed by the content of register X (0 to 3) </td></tr>
<tr>
<td>STSHA </td><td>Copy 20 bytes from W into SHA register </td></tr>
<tr>
<td>STSHA256 (v6.0+) </td><td>Copy 32 bytes from W into SHA register </td></tr>
<tr>
<td colspan="2"><em>OP codes labeled (v2.0+) are only available in version 2.0 of the VSS interpreter and higher.<br  />
 OP codes labeled (v4.0+) are only available in version 4.0 of the VSS interpreter and higher.</em> </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>DUKPT Commands</b> </td></tr>
<tr>
<td>INIT_1DES_DUKPT (v4.0+) </td><td>Initialize Single DES DUKPT <ul>
<li>
IKSN is the first 10 bytes of the CB </li>
<li>
IK is in register B0 </li>
</ul>
</td></tr>
<tr>
<td>INIT_3DES_DUKPT (v4.0+) </td><td>Initialize Triple DES DUKPT <ul>
<li>
IKSN is the first 10 bytes of the CB </li>
<li>
IKL is in register B0 </li>
<li>
IKR is in register B1 </li>
</ul>
</td></tr>
<tr>
<td>DELETE_DUKPT_KEY (v4.0+) </td><td>Delete the DUKPT key </td></tr>
<tr>
<td>GET_DUKPT_KEY (v4.0+) </td><td>Get type/status, the KSN and the DUKPT FK <ul>
<li>
Type/Status is in register X </li>
<li>
KSN is the first 10 bytes of the CB </li>
<li>
FK (1DES) or FKL (3DES) is in register B0 </li>
<li>
FKR (3DES) is in register B1 </li>
<li>
The OS will derive the next FK </li>
</ul>
</td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>MAC Operations</b> </td></tr>
<tr>
<td colspan="2"><em>Added VSS op codes to MAC data in the VSS communication buffer.</em> </td></tr>
<tr>
<td>ALGO_MAC00 (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 1 – 56 Bits <br  />
K is a single length key (VSS K1) </td></tr>
<tr>
<td>ALGO_MAC10 (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 1 – 112 Bits <br  />
K is a double length key (VSS K1 and K2) </td></tr>
<tr>
<td>ALGO_MAC20 (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 2 – 112 Bits <br  />
K is a single length key (VSS K1) <br  />
K’’’ is a single length key (VSS K2) </td></tr>
<tr>
<td>ALGO_MAC20_LAST (v6.0+) </td><td>When the last block is MACed, do last block processing <br  />
Can MAC, 1 or more blocks. </td></tr>
<tr>
<td>ALGO_MAC30 (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 3 – 112 Bits <br  />
K is a single length key (VSS K1) <br  />
K’ is a single length key (VSS K2) </td></tr>
<tr>
<td>ALGO_MAC30_LAST (v6.0+) </td><td>When the last block is MACed, do last block processing <br  />
Can MAC, 1 or more blocks. </td></tr>
<tr>
<td>ALGO_MAC40 (v6.0+) </td><td>Middle block processing </td></tr>
<tr>
<td>ALGO_MAC40_FIRST (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 4 – 112 Bits <br  />
When the first block is MACed, do first block processing <br  />
Can MAC, 1 or more blocks. <br  />
K is a single length key (VSS K1) <br  />
K’’ is a single length key (VSS K1 XOR 0xF0F0F0F0F0F0F0F0) <br  />
K’ is a single length key (VSS K2) </td></tr>
<tr>
<td>ALGO_MAC40_LAST (v6.0+) </td><td>When the last block is MACed, do last block processing <br  />
Can MAC, 1 or more blocks </td></tr>
<tr>
<td>ALGO_MAC50 (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 5 – 56 Bits <br  />
K1 is a single length key (VSS K1) <br  />
K2 is a single length key (VSS K1 XOR 0xF0F0F0F0F0F0F0F0) </td></tr>
<tr>
<td>ALGO_MAC50_LAST (v6.0+) </td><td>When the last block is MACed, do last block processing <br  />
Can MAC, 1 or more blocks </td></tr>
<tr>
<td>ALGO_MAC60 (v6.0+) </td><td>ISO 9797-1 MAC Algorithm 5 – 112 Bits <br  />
K1 is a double length key (VSS K1 and K2) <br  />
K2 is a double length key (VSS K1 XOR 0xF0F0F0F0F0F0F0F0) <br  />
(VSS K2 XOR 0xF0F0F0F0F0F0F0F0) </td></tr>
<tr>
<td>ALGO_MAC60_LAST (v6.0+) </td><td>When the last block is MACed, do last block processing <br  />
Can MAC, 1 or more blocks </td></tr>
<tr>
<td>MAC_CB offset length (v6.0+) </td><td>MAC the data in the communication buffer starting at offset for length </td></tr>
<tr>
<td>MAC_CB_X offset (v6.0+) </td><td>MAC the data in the communication buffer starting at offset for length in X <br  />
Must set or clear IV before start of MAC <br  />
Must select algorithm and then key before execution of OP code <br  />
Length must be a multiple of 8 bytes, so data must be padded <br  />
Result in IV, all 8 bytes, data not truncated </td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Padding Commands</b> </td></tr>
<tr>
<td>OAEP </td><td>Encode message M in register W, result EM in register W </td></tr>
<tr>
<td>(v7.0+) </td><td>Decode message EM in register W, result M in register W <ul>
<li>
CB - optional label L </li>
<li>
Register X - Encode/Decode </li>
<li>
Register A - OAEP options and lengths </li>
</ul>
</td></tr>
<tr>
<td colspan="2" style="background-color:#D6EAF8"><b>Exit Commands</b> </td></tr>
<tr>
<td>EOM length </td><td>End of Macro - Delete register A, B0, B1, CK and X - Send to terminal length bytes of CB </td></tr>
<tr>
<td>ERR_RET length (v2.0+) </td><td>Error Return from Macro - Delete register A, B0, B1, CK and X - Send to terminal length bytes of CB. This command will also have a non-zero return value (E_VS_ERR_RET). This OP code can be used for returning custom errors or for debugging. The macro can place error or debug data in the CB to be returned to the application </td></tr>
<tr>
<td colspan="2"><em>OP codes labeled (v2.0+) are only available in version 2.0 of the VSS interpreter and higher. <br  />
OP codes labeled (v4.0+) are only available in version 4.0 of the VSS interpreter and higher.</em> </td></tr>
</table>
<p>A macro performs some of the following actions:</p><ul>
<li>Check the length of the data field received into the communication buffer using the LENGTH command</li>
<li>Copy the input data into the register A and index register X using GETA and GETAX commands</li>
<li>Perform logical and cryptographic operations on the working registers</li>
<li>Perform comparisons using CMPA commands</li>
<li>Copy the result into a block location using STA or into the communication buffer using the SENDA command</li>
<li>Erase the working registers and transmit the response packet using the EOM command</li>
</ul>
<h2><a class="anchor" id="subsec_vss_detailed_description_of_keywords"></a>
Detailed Description of Keywords</h2>
<p>This section provides the description of the keywords used in the security scripts.</p>
<h3><a class="anchor" id="subsubsec_vss_configuration_instructions"></a>
Configuration Instructions</h3>
<a class="anchor" id="multi_row4"></a>
<table class="doxtable">
<caption style="text-align:left">Table 4 SUBDEV</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SUBDEV id (Script number (Sub-Device Number), range is [0..7]) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>id <br  />
<ul>
<li>[0..63] in VSS version 5.0+ <br  />
</li>
<li>[0..95] in VSS version 8.0+ <br  />
</li>
<li>[0..191] in VSS version 9.0+ </li>
</ul>
</td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>VSS devices can have up to 8 scripts. <br  />
<ul>
<li>64 in VSS version 5.0+ <br  />
</li>
<li>96 in VSS version 8.0+ <br  />
</li>
<li>192 in VSS version 9.0+ <br  />
 This keyword defines in which of those 8 locations the script will be loaded. <br  />
</li>
<li>64 in VSS version 5.0+ <br  />
</li>
<li>96 in VSS version 8.0+ <br  />
</li>
<li>192 in VSS version 9.0+ <br  />
 The script number is also used at execution time to select the script to execute from. </li>
</ul>
</td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Macro commands defined in this file will be accessed using the <code> ExecuteScript() </code> function with the value id as first argument. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row5"></a>
<table class="doxtable">
<caption style="text-align:left">Table 5 SCRIPT</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SCRIPT name (Identifier). Must be 8 ASCII characters. Should be unique per script (should contain a version number) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>name </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword is used to identify a script </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row6"></a>
<table class="doxtable">
<caption style="text-align:left">Table 6 PP1000_OFF</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">PP1000_OFF </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>None - Ignored </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row7"></a>
<table class="doxtable">
<caption style="text-align:left">Table 7 MS_OFF</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MS_OFF </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword disables Master/Session support. If at least one of the scripts loaded in the unit contains this keyword, the number of PIN and MAC M/S Master Keys is set to zero and the API functions are disabled (will return an error code). Used in SC 5000. Ignored in Vx terminals </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row8"></a>
<table class="doxtable">
<caption style="text-align:left">Table 8 DUKPT_OFF</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DUKPT_OFF </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword disables all the DUKPT support. If at least one of the scripts loaded in the unit contains this keyword, the DUKPT keys are erased and the related API functions are disabled (return an error code). Used in SC 5000. Ignored in Vx terminals </td></tr>
</table>
<p><br  />
</p>
<h3><a class="anchor" id="subsubsec_vss_key_definition_instructions"></a>
Key Definition Instructions</h3>
<a class="anchor" id="multi_row9"></a>
<table class="doxtable">
<caption style="text-align:left">Table 9 DEF_BLK</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DEF_BLK total loadable Total number of 8-byte block that will be allocated.<br  />
 total Range [0..255]<br  />
 loadable Number of blocks that will be loadable using the generic key loading functions. Range [0..total] </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword is used to define the block area. <br  />
 Total blocks will be allocated at the time the script is installed in the unit. Out of those blocks only blocks <code>#0</code> to <code>#loadable-1</code> will be loadable using the generic API functions <code>LoadMasterClearKey()</code> and <code>LoadMasterEncKey()</code>. If loadable is greater than total, then the script loading will fail. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row10"></a>
<table class="doxtable">
<caption style="text-align:left">Table 10 RETAIN_BLK</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">RETAIN_BLK code </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>code (8-byte cryptogram) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword is used to indicate that this script will use the same block definition as the script previously installed in the same slot and that the values in the blocks must be retained. <br  />
 A code must be presented in order to authorize this operation. <br  />
 The code is the result of the following computation that is based on KLK and the name of the previous script under KLK. <br  />
 CODE = TDES [KLK xor (NAME | NAME)](NAME) where: <ul>
<li>
NAME is the 8-character name of the script to be replaced </li>
<li>
(NAME | NAME) is the concatenation of two NAMEs to form a 16-byte value that will be exclusive-or’d with KLK to form the double-length encryption key </li>
<li>
CODE is the result of the triple-DES encryption of NAME under this key </li>
<li>
Both scripts must use the same Sub-device number (SUBDEV id) </li>
</ul>
</td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td width="1000">NAME = “A40_V100” = 4134305F56313030 <br  />
KLK = “0000000800000002” = 30303030303030383030303030303032 <br  />
 NAME | NAME = “A40_V100A40_V100” = 4134305F563130304134305F56313030 <br  />
 KEY = KLK XOR (NAME | NAME) = 7104006F660100087104006F66010002 <br  />
 CODE = TDES[KEY](NAME) = 3BD985379859818C <br  />
 For v6.0 and higher - can also use fixed retain block value of ASCII Hex value of the name of the previous script. <br  />
 Example: <br  />
 Previous script name "A40_V100" = 4134305F56313030 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row11"></a>
<table class="doxtable">
<caption style="text-align:left">Table 11 LD_BLK</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LD_BLK index value </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (Block location)<br  />
value (8-byte value to be loaded in the block) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword is used to load a default value into the block <code>#index</code> at the time the script is installed in the unit. </td></tr>
</table>
<p><br  />
</p>
<h3><a class="anchor" id="subsubsec_vss_macro_command_instructions"></a>
Macro Command Instructions</h3>
<a class="anchor" id="multi_row12"></a>
<table class="doxtable">
<caption style="text-align:left">Table 12 ADDXI</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ADDXI value </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>Value (One byte value) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The immediate value is added to the single-byte register X </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row13"></a>
<table class="doxtable">
<caption style="text-align:left">Table 13 ADJ_EVEN / ADJ_ODD</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ADJ_EVEN <br  />
ADJ_ODD </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Adjust the parity of each byte in the register A by changing the least significant bit (rightmost) of the byte. ADJ_EVEN ensures there are even number of bits set to 1 in each byte. ADJ_ODD ensures there are odd number of bits set to 1 in each byte </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>In versions 3.13 and earlier of the SC 5000 RAM OS, those two instructions do not work correctly: If one byte in the 8-byte buffer has the correct parity, then the remaining bytes in the buffer (on the right) will not get their parity adjusted. A temporary workaround in the script is to alternate 8 ADJ_ODD and ADJ_EVEN OP codes to make sure that the entire 8-byte buffer gets adjusted. For instance, in the script: <br  />
 ADJ_EVEN <br  />
 should be replaced by <br  />
 ADJ_ODD <br  />
ADJ_EVEN <br  />
ADJ_ODD <br  />
ADJ_EVEN <br  />
ADJ_ODD <br  />
ADJ_EVEN <br  />
ADJ_ODD <br  />
ADJ_EVEN </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row14"></a>
<table class="doxtable">
<caption style="text-align:left">Table 14 ALGO_DES56 / ALGO_DES112 / ALGO_DES168 / ALGO_AES128 / ALGO_AES192 / ALGO_AES256</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_DES56 <br  />
ALGO_DES112 <br  />
ALGO_DES168 <br  />
ALGO_AES128 <br  />
ALGO_AES192 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>This instruction sets the algorithm and key length for the upcoming instructions in the same macro command. <br  />
 ALGO_DES56: simple DEA with simple-length key <br  />
 ALGO_DES112: triple-DEA with double-length key <br  />
 ALGO_DES168: triple-DEA with triple-length key <br  />
 ALGO_AES128: AES (Rijndael) with 128-bit key (128-bit data block) <br  />
 ALGO_AES192: AES (Rijndael) with 192-bit key (128-bit data block) <br  />
 ALGO_AES256: AES (Rijndael) with 256-bit key (128-bit data block) <br  />
 This setting has an effect on the following instructions: <br  />
 SELECT, SELECTA, EECB, DECB, ECBC, DCBC, MOV_A_IV, MOV_IV_A </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The algorithm is reset to simple-DES (ALGO_DES56) at the beginning of every macro command, this means, the setting is not retained between two macro command calls </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row15"></a>
<table class="doxtable">
<caption style="text-align:left">Table 15 ALGO_MAC00 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC00 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 1 – 56 Bits <br  />
 K is a single length key (VSS K1) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row16"></a>
<table class="doxtable">
<caption style="text-align:left">Table 16 ALGO_MAC10 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC10 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 1 – 112 Bits <br  />
 K is a double length key (VSS K1 and K2) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row17"></a>
<table class="doxtable">
<caption style="text-align:left">Table 17 ALGO_MAC20 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC20 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 2 – 112 Bits <br  />
 K is a single length key (VSS K1) <br  />
 K’’’ is a single length key (VSS K2) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row18"></a>
<table class="doxtable">
<caption style="text-align:left">Table 18 ALGO_MAC20_LAST (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC20_LAST </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>When the last block is MACed, do last block processing Can MAC, 1 or more blocks </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row19"></a>
<table class="doxtable">
<caption style="text-align:left">Table 19 ALGO_MAC30 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC30 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 3 – 112 Bits <br  />
 K is a single length key (VSS K1) <br  />
 K’ is a single length key (VSS K2) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row20"></a>
<table class="doxtable">
<caption style="text-align:left">Table 20 ALGO_MAC30_LAST (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC30_LAST </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>When the last block is MACed, do last block processing Can MAC, 1 or more blocks </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row21"></a>
<table class="doxtable">
<caption style="text-align:left">Table 21 ALGO_MAC40_FIRST (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC40_FIRST </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 4 – 112 Bits <br  />
 When the first block is MACed, do first block processing <br  />
 Can MAC, 1 or more blocks <br  />
 K is a single length key (VSS K1) <br  />
 K’’ is a single length key (VSS K1 XOR 0xF0F0F0F0F0F0F0F0) <br  />
 K’ is a single length key (VSS K2) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row22"></a>
<table class="doxtable">
<caption style="text-align:left">Table 22 ALGO_MAC40 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC40 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>Middle block processing </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row23"></a>
<table class="doxtable">
<caption style="text-align:left">Table 23 ALGO_MAC40_LAST (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC40_LAST </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>When the last block is MACed, do last block processing Can MAC, 1 or more blocks </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row24"></a>
<table class="doxtable">
<caption style="text-align:left">Table 24 ALGO_MAC50 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC50 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 5 – 56 Bits <br  />
 K1 is a single length key (VSS K1) <br  />
 K2 is a single length key (VSS K1 XOR 0xF0F0F0F0F0F0F0F0) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row25"></a>
<table class="doxtable">
<caption style="text-align:left">Table 25 ALGO_MAC50_LAST (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC50_LAST </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>When the last block is MACed, do last block processing Can MAC, 1 or more blocks </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row26"></a>
<table class="doxtable">
<caption style="text-align:left">Table 26 ALGO_MAC60 (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC60 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>ISO 9797-1 MAC Algorithm 5 – 112 Bits <br  />
 K1 is a double length key (VSS K1 and K2) <br  />
 K2 is a double length key (VSS K1 XOR 0xF0F0F0F0F0F0F0F0) <br  />
 (VSS K2 XOR 0xF0F0F0F0F0F0F0F0) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row27"></a>
<table class="doxtable">
<caption style="text-align:left">Table 27 ALGO_MAC60_LAST (v6.0+)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ALGO_MAC60_LAST </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>When the last block is MACed, do last block processing Can MAC, 1 or more blocks </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 6.0 of the VSS interpreter and higher </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row28"></a>
<table class="doxtable">
<caption style="text-align:left">Table 28 BRA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">BRA Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>Label (The Label to branch to) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>A branch is taken to the Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is available only in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row29"></a>
<table class="doxtable">
<caption style="text-align:left">Table 29 CHK_EVEN / CHK_ODD</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CHK_EVEN <br  />
CHK_ODD </td></tr>
<tr>
<td style="background-color:#D6EAF8">Optional </td><td>Check the parity of each byte in register A. If one byte is not of the expected parity, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>).<br  />
 CHK_EVEN verifies that each byte has even number of bits set to 1. <br  />
 CHK_ODD verifies that each byte has odd number of bits set to 1. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row30"></a>
<table class="doxtable">
<caption style="text-align:left">Table 30 CHK_EVEN_BNE / CHK_ODD_BNO</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CHK_EVEN_BNE Label <br  />
CHK_ODD_BNO Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>Label - The Label to branch to. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Check the parity of each byte in register A. If one byte is not of the expected parity, (Even - even number of bits set to 1, Odd - odd number of bits set to 1), then the macro command execution branches to the Label, otherwise the next OP Code is executed. <br  />
 CHK_EVEN_BNE if all bytes are not even parity, branch to Label <br  />
 CHK_ODD_BNO if all bytes are not odd parity, branch to Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>These OP codes are available only in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row31"></a>
<table class="doxtable">
<caption style="text-align:left">Table 31 CLRA/SETA/RNDA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CLRA <br  />
SETA <br  />
RNDA <br  />
 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>The instructions fill the register A with 00h (CLRA), FFh (SETA) or random bytes (RNDA). </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Even though the same operation can be accomplished using LDAI, it is recommended to use CLRA and SETA because they are coded on one byte instead of nine for LDAI. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row32"></a>
<table class="doxtable">
<caption style="text-align:left">Table 32 CLRIV</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CLRIV </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of the Initialization Vectors (IV-0 and IV-1) is cleared (filled with 00h) </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row33"></a>
<table class="doxtable">
<caption style="text-align:left">Table 33 COMA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">COMA </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Each byte of register A is complemented (one’s complement) </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row34"></a>
<table class="doxtable">
<caption style="text-align:left">Table 34 CMPA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPA index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (block location) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Compare the content of register A with the content of the block <code>#index</code>. <br  />
 If the comparison fails, the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>) </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row35"></a>
<table class="doxtable">
<caption style="text-align:left">Table 35 CMPA_BEQ / CMPA_BNE / CMPA_BGT / CMPA_BLT / CMPA_BGE / CMPA_BLE</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPA_BEQ index Label <br  />
 CMPA_BNE index Label <br  />
 CMPA_BGT index Label <br  />
 CMPA_BLT index Label <br  />
 CMPA_BGE index Label <br  />
 CMPA_BLE index Label <br  />
 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (block location) <br  />
 Label (Label to branch to) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Unsigned compare the content of register A with the content of the block <code>#index</code>. <br  />
 If the comparison is true, a branch is made to Label, otherwise the next OP Code is executed. <br  />
 CMPA_BEQ if A = block <code>#index</code>, branch to Label <br  />
 CMPA_BNE if A != block <code>#index</code>, branch to Label <br  />
 CMPA_BGT if A &gt; block <code>#index</code>, branch to Label <br  />
 CMPA_BLT if A &lt; block <code>#index</code>, branch to Label <br  />
 CMPA_BGE if A &gt;= block <code>#index</code>, branch to Label <br  />
 CMPA_BLE if A &lt;= block <code>#index</code>, branch to Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>These OP codes are only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row36"></a>
<table class="doxtable">
<caption style="text-align:left">Table 36 CMPA_B0/CMPA_B1</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPA_B0 <br  />
CMPA_B1 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Compare the content of the register A with the content of the register B0 (CMPA_B0) or B1 (CMPA_B1). <br  />
 If the comparison fails, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row37"></a>
<table class="doxtable">
<caption style="text-align:left">Table 37 CMPA_B0_BEQ / CMPA_B0_BNE / CMPA_B0_BGT / CMPA_B0_BLT / CMPA_B0_BGE / CMPA_B0_BLE / CMPA_B1_BEQ / CMPA_B1_BNE / CMPA_B1_BGT / CMPA_B1_BLT / CMPA_B1_BGE / CMPA_B1_BLE</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPA_B0_BEQ Label <br  />
 CMPA_B0_BNE Label <br  />
 CMPA_B0_BGT Label <br  />
 CMPA_B0_BLT Label <br  />
 CMPA_B0_BGE Label <br  />
 CMPA_B0_BLE Label <br  />
 CMPA_B1_BEQ Label <br  />
 CMPA_B1_BNE Label <br  />
 CMPA_B1_BGT Label <br  />
 CMPA_B1_BLT Label <br  />
 CMPA_B1_BGE Label <br  />
 CMPA_B1_BLE Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameter </td><td>Label (Label to branch to) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Unsigned compare the content of register A with the content of B0 or B1. If the comparison is true, a branch is made to Label, otherwise the next OP Code is executed. <br  />
 CMPA_B0_BEQ if A = B0, branch to Label <br  />
 CMPA_B0_BNE if A != B0, branch to Label <br  />
 CMPA_B0_BGT if A &gt; B0, branch to Label <br  />
 CMPA_B0_BLT if A &lt; B0, branch to Label <br  />
 CMPA_B0_BGE if A &gt;= B0, branch to Label <br  />
 CMPA_B0_BLE if A &lt;= B0, branch to Label <br  />
 CMPA_B1_BEQ if A = B1, branch to Label <br  />
 CMPA_B1_BNE if A != B1, branch to Label <br  />
 CMPA_B1_BGT if A &gt; B1, branch to Label <br  />
 CMPA_B1_BLT if A &lt; B1, branch to Label <br  />
 CMPA_B1_BGE if A &gt;= B1, branch to Label <br  />
 CMPA_B1_BLE if A &lt;= B1, branch to Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>These OP codes are only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row38"></a>
<table class="doxtable">
<caption style="text-align:left">Table 38 CMPAX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPAX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameter </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Compare the register A with the block pointed by the content of register X. <br  />
 If the comparison fails, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row39"></a>
<table class="doxtable">
<caption style="text-align:left">Table 39 CMPAX_BEQ / CMPAX_BNE / CMPAX_BGT / CMPAX_BLT / CMPAX_BGE / CMPAX_BLE</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPAX_BEQ Label <br  />
 CMPAX_BNE Label <br  />
 CMPAX_BGT Label <br  />
 CMPAX_BLT Label <br  />
 CMPAX_BGE Label <br  />
 CMPAX_BLE Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameter </td><td>Label (Label to branch to) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Unsigned compare the content of register A with the content of the block, pointed to by the content of register X. If the comparison is true, then a branch is made to Label, otherwise the next Op Code is executed. <br  />
 CMPAX_BEQ if A = block pointed to by register X, branch to Label <br  />
 CMPAX_BNE if A != block pointed to by register X, branch to Label <br  />
 CMPAX_BGT if A &gt; block pointed to by register X, branch to Label <br  />
 CMPAX_BLT if A &lt; block pointed to by register X, branch to Label <br  />
 CMPAX_BGE if A &gt;= block pointed to by register X, branch to Label <br  />
 CMPAX_BLE if A &lt;= block pointed to by register X, branch to Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>These OP codes are only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row40"></a>
<table class="doxtable">
<caption style="text-align:left">Table 40 CMPSHA / CMPSHA256</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPSHA / CMPSHA256 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Compare the content of the SHA register with the first 20 bytes of SHA and 32 bytes of SHA256 of register W. <br  />
 If the comparison fails, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>CMPSHA256 OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row41"></a>
<table class="doxtable">
<caption style="text-align:left">Table 41 CMPSHA_BEQ / CMPSHA_BNE/CMPSHA256_BEQ / CMPSHA256_BNE</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">CMPSHA_BEQ Label <br  />
 CMPSHA_BNE Label <br  />
 CMPSHA256_BEQ Label <br  />
 CMPSHA256_BNE Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>Label (Label to branch to) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Compare the content of the SHA register with the first 20 bytes of SHA and 32 bytes of SHA256 of register W. If the comparison is true, a branch is made to Label, otherwise the next Op Code is executed. <br  />
 CMPSHA_BEQ / CMPSHA256_BEQ if W = SHA, branch to Label <br  />
 CMPSHA_BNE / CMPSHA256_BNE if W != SHA, branch to Label. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>CMPSHA_BEQ / CMPSHA_BNE OP codes are only available in version 2.0 of the VSS interpreter and higher. <br  />
 CMPSHA256_BEQ / CMPSHA256_BNE OP codes are only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row42"></a>
<table class="doxtable">
<caption style="text-align:left">Table 42 DECIM0 (PVV &amp; PAC Shell Formats)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DECIM0 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This function decimalizes the content of register A using the PVV and PAC Shell formats: <br  />
 From left to right, take only the digits (nibbles) =&lt; 9. <br  />
 Then take the digits &gt; 9 and apply mod 10. <br  />
 For PVV only the 4 first bytes must be kept, For PAC Shell only the first 3 bytes. This is not done by this instruction. <br  />
 Refer to VDN 15471 for Description of the algorithms. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Reg A Before: FE A1 26 D4 E4 89 66 6F <br  />
 Reg A After: 12 64 48 96 66 54 03 45 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row43"></a>
<table class="doxtable">
<caption style="text-align:left">Table 43 DECIM1 (IBM3624 Format)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DECIMI </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This function decimalizes the content of register A using the IBM3624 with offset format: <br  />
 The decimalization table must be in register B0. <br  />
 Refer to VDN 15471 for Description of the IBM3624 algorithm. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Reg B0 (dec. table) 85 05 32 01 39 24 16 74 <br  />
 Reg A Before: CA EC A9 73 22 EE FF D0 <br  />
 Reg A After: 12 71 29 15 00 77 44 68 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row44"></a>
<table class="doxtable">
<caption style="text-align:left">Table 44 DECIM2 (CCV Format)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DECIM2 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This function decimalizes the content of register A using the CCV format: <br  />
 Apply mod 10 on each nibble. <br  />
 Refer to VDN 15471 for Description of the CCV algorithm. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Reg A Before: FE A1 26 D4 E4 89 66 6F <br  />
 Reg A After: 54 01 26 34 44 89 66 65 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row45"></a>
<table class="doxtable">
<caption style="text-align:left">Table 45 DELETE</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DELETE index_from index_to </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td><code>index_fromfirst</code> block location to be deleted. <br  />
 <code>index_tolast</code> block location to be deleted. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction deletes all the blocks from block <code>#index_from</code> to block <code>#index_to</code>. The deletion is done by writing a fixed value in the block and marking it as not loaded. If index_from is greater than index_to or if one index is out-ofrange, then macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). <br  />
 Use index_to = index_from, to delete one block only. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row46"></a>
<table class="doxtable">
<caption style="text-align:left">Table 46 DELETEX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DELETEX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction deletes the block pointed by the content of register X. <br  />
 The deletion is done by writing a random value in the block and marking it as not loaded. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row47"></a>
<table class="doxtable">
<caption style="text-align:left">Table 47 DELETE_DUKPT_KEY</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">DELETE_DUKPT_KEY </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction deletes the DUKPT Key. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>These OP codes are only available in version 4.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row48"></a>
<table class="doxtable">
<caption style="text-align:left">Table 48 ECBC / DCBC</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ECBC <br  />
DCBC </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Perform an encryption (ECBC) or decryption (DCBC) in CBC mode. <br  />
 If the algorithm selected is DES, then the computation is performed on the register A with result in A (IV-0 for intermediate result). <br  />
 If the algorithm selected is AES, then the computation is performed on register A and B0 with result in A and B0 (B0 is used for the second part of the data, IV-0 and IV-1 for intermediate result). <br  />
 This instruction uses the current key registers CK differently depending on the selected algorithm: <br  />
\ ALGO_DES56 uses CK-0 only <br  />
 ALGO_DES112, ALGO_AES128 uses CK-0 and CK-1 <br  />
 ALGO_DES168, ALGO_AES192 uses CK-0, CK-1 and CK-2 <br  />
 ALGO_AES256 uses CK-0, CK-1, CK-2 and CK-3 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row49"></a>
<table class="doxtable">
<caption style="text-align:left">Table 49 ECBC_CB / DCBC_CB</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ECBC_CB offset length <br  />
DCBC_CB offset length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Perform an encryption (ECBC_CB) or decryption (DCBC_CB) in CBC mode on the data in the communication buffer starting at offset for length. <br  />
 Result in communication buffer. The data is replaced. <br  />
 Must select algorithm and then key before execution of the OP code. <br  />
 Length must be a multiple of 8 bytes for DES and 16 bytes for AES, so data must be padded. <br  />
 Must set or clear IV before starting encryption/decryption. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>These OP codes are only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row50"></a>
<table class="doxtable">
<caption style="text-align:left">Table 50 ECBC_CB_X / DCBC_CB_X</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">Format ECBC_CB_X offset <br  />
DCBC_CB_X offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Perform an encryption (ECBC_CB_X) or decryption (DCBC_CB_X) in CBC mode on the data in the communication buffer starting at offset for length in X. <br  />
 Result in communication buffer. The data is replaced. <br  />
 Must select algorithm and then key before execution of the OP code. <br  />
 Length must be a multiple of 8 bytes for DES and 16 bytes for AES, so data must be padded. <br  />
 Must set or clear IV before starting encryption/decryption. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>These OP codes are only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row51"></a>
<table class="doxtable">
<caption style="text-align:left">Table 51 EECB / DECB</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">EECB <br  />
DECB </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Perform an encryption (EECB) or decryption (DECB) in ECB mode. <br  />
 If the algorithm selected is DES then the computation is performed on register A with result in A. <br  />
 If the algorithm selected is AES, then the computation is performed on register A and B0 with result in A and B0 (B0 is used for the second part of the data). <br  />
 This instruction uses the current key registers CK differently depending on the selected algorithm: <br  />
 ALGO_DES56uses CK-0 only <br  />
 ALGO_DES112, ALGO_AES128uses CK-0 and CK-1 <br  />
 ALGO_DES168, ALGO_AES192uses CK-0, CK-1 and CK-2 <br  />
 ALGO_AES256uses CK-0, CK-1, CK-2 and CK-3 <br  />
 This instruction does not use the Initialization Vector. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row52"></a>
<table class="doxtable">
<caption style="text-align:left">Table 52 EECB_CB / DECB_CB</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">EECB_CB offset length <br  />
DECB_CB offset length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Perform an encryption (EECB_CB) or decryption (DECB_CB) in ECB mode on the data in the communication buffer starting at offset for length. <br  />
 Result in communication buffer. The data is replaced. <br  />
 Must select algorithm and then key before execution of the OP code. <br  />
 Length must be a multiple of 8 bytes for DES and 16 bytes for AES, so data must be padded. <br  />
 These instructions do not use the IV. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>These OP codes are only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row53"></a>
<table class="doxtable">
<caption style="text-align:left">Table 53 EECB_CB_X / DECB_CB_X</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">EECB_CB_X offset <br  />
DECB_CB_X offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Perform an encryption (EECB_CB_X) or decryption (DECB_CB_X) in ECB mode on the data in the communication buffer starting at offset for length in X. <br  />
 Result in communication buffer. The data is replaced. <br  />
 Must select algorithm and then key before execution of the OP code. <br  />
 Length must be a multiple of 8 bytes for DES and 16 bytes for AES, so data must be padded. <br  />
 These instructions do not use the IV. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>These OP codes are only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row54"></a>
<table class="doxtable">
<caption style="text-align:left">Table 54 EOM</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">EOM length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>length (Number of bytes to be returned) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>End of Macro. <br  />
 This keyword terminates the OP Code string and instructs the interpreter to return length bytes from the communication buffer in the response packet. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row55"></a>
<table class="doxtable">
<caption style="text-align:left">Table 55 ERR_RET</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">ERR_RET length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>length (Number of bytes to be returned) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Error Return from Macro. <br  />
 This command will have a non-zero return value (E_VS_ERR_RET). It can be used for returning custom errors or for debugging. The macro can place error or debug data in the CB to be returned to the application. <br  />
 This keyword terminates the OP code string and instructs the interpreter to return length bytes from the communication buffer in the response packet. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row56"></a>
<table class="doxtable">
<caption style="text-align:left">Table 56 GET_DUKPT_KEY</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GET_DUKPT_KEY </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Get the Type/Status, the Key Serial Number (KSN), and the DUKPT Future Key (FK) <br  />
 The Type/Status is in register X. <br  />
 <code>X = 0 – Single DES DUKPT Key </code><br  />
 <code>X = 1 – Triple DES DUKPT Key </code><br  />
 <code>X = 2 – DUKPT Not Initialized </code><br  />
 <code>X = 3 – DUKPT Key Exhaustion – End of Life</code> <br  />
 The Key Serial Number (KSN) is the first 10 bytes (0-9) of the communication buffer. <br  />
 The Future Key: <br  />
 <b><code>Single DES DUKPT Key:</code></b> <br  />
 <code>Future Key (FK) is in B0.</code> <br  />
 <b><code>Triple DES DUKPT Key:</code></b> <br  />
 <code>Future Key Left (FKL) is in B0.</code> <br  />
 <code>Future Key Right (FKR) is in B1.</code> <br  />
 The OS will derive the next Future Key (FK). </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>This OP code is only available in version 4.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row57"></a>
<table class="doxtable">
<caption style="text-align:left">Table 57 GETA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETA offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (offset in the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>End of Macro. <br  />
 This keyword terminates the OP code string and instructs the interpreter to return length bytes from the communication buffer in the response packet. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row58"></a>
<table class="doxtable">
<caption style="text-align:left">Table 58 GETA_HA_TO_BIN</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETA_HA_TO_BIN offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (offset in the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>16 bytes from the position offset in the communication buffer are converted from Hex ASCII (‘0’-‘9’, ‘A’-‘F’, ‘a’-‘f’) to Binary and the 8 Binary bytes are copied into register A. <br  />
 At the beginning of the macro command the communication buffer contains only the data field of the incoming command. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comment </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row59"></a>
<table class="doxtable">
<caption style="text-align:left">Table 59 GETPINNB</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETPINNB </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>After the PIN entry session is finished, this instruction can be used to transfer the number of PIN digits entered into the first (leftmost) byte of the register A. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Entered PIN: 1234 <br  />
 Reg A Before: aa bb cc dd ee ff gg hh <br  />
 Reg A After: 04 bb cc dd ee ff gg hh </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row60"></a>
<table class="doxtable">
<caption style="text-align:left">Table 60 GETPINO (one nibble per digit, starting from the left)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETPINO </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>After the PIN entry session is finished, this instruction can be used to transfer the PIN digits into the register A, one nibble per digit starting at the leftmost position. After this operation the PIN is deleted from the keyboard buffer. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Entered PIN: 1234 <br  />
 Reg A Before: aa bb cc dd ee ff gg hh <br  />
 Reg A After: 12 34 aa bb cc dd ee ff </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row61"></a>
<table class="doxtable">
<caption style="text-align:left">Table 61 GETPIN1 (One nibble per digit, starting from the right)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETPIN1 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>After the PIN entry session is finished, this instruction can be used to transfer the PIN digits into the register A, one nibble per digit starting at the rightmost position. After this operation the PIN is deleted from the keyboard buffer. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Entered PIN: 1234 <br  />
 Reg A Before: aa bb cc dd ee ff gg hh <br  />
 Reg A After: cc dd ee ff gg hh 12 34 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row62"></a>
<table class="doxtable">
<caption style="text-align:left">Table 62 GETPIN2 (One byte per digit and per call, starting from the right)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETPIN2 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>After the PIN entry session is finished, this instruction can be used to transfer the PIN into the register A one byte (digit) at a time. The content of the register A is shifted to the right before the transfer. The digit transferred to A is then deleted from the keyboard buffer. <br  />
 If no PIN digit is left in the keyboard buffer, then the command is ignored and the register A is not shifted. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Entered PIN: 1234 <br  />
 Reg A Before: aa bb cc dd ee ff gg hh <br  />
 Reg A After 1st call: 34 aa bb cc dd ee ff gg <br  />
 Reg A After 2nd call: 33 34 aa bb cc dd ee ff <br  />
 Reg A After 3rd call: 32 33 34 aa bb cc dd ee <br  />
 Reg A After 4th call: 31 32 33 34 aa bb cc dd </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row63"></a>
<table class="doxtable">
<caption style="text-align:left">Table 63 GETPIN3 (“Smart Card” format)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETPIN3 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The Pin is transferred into the register A as 2 times the 4 ASCII bytes of the pin. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Entered PIN: 1234 <br  />
 Reg A Before: aa bb cc dd ee ff gg hh <br  />
 Reg A After: 31 32 33 34 31 32 33 34 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row64"></a>
<table class="doxtable">
<caption style="text-align:left">Table 64 GETW</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETW offset length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (offset in the communication buffer) <br  />
length (number of bytes) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>length bytes from the position offset in the communication buffer is copied in register W. At the beginning of the macro command the communication buffer contains only the data field of the incoming command. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row65"></a>
<table class="doxtable">
<caption style="text-align:left">Table 65 GETW_HA_TO_BIN</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETW_HA_TO_BIN offset length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (offset in the communication buffer) <br  />
length (number of bytes - must be even) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>length bytes from the position offset in the communication buffer are converted from Hex ASCII (‘0’-‘9’, ‘A’-‘F’, ‘a’-‘f’) to Binary and length/2 Binary bytes are copied into W. <br  />
 At the beginning of the macro command the communication buffer contains only the data field of the incoming command. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row66"></a>
<table class="doxtable">
<caption style="text-align:left">Table 66 GETX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETX offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (offset is the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>One byte from the position offset in the communication buffer is copied into register X. <br  />
 At the beginning of the macro command the communication buffer contains only the data field of the incoming command. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row67"></a>
<table class="doxtable">
<caption style="text-align:left">Table 67 GETX_HA_TO_BIN</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">GETX_HA_TO_BIN offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (offset is the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>2 bytes from the position offset in the communication buffer are converted from Hex ASCII (‘0’-‘9’, ‘A’-‘F’, ‘a’-‘f’) to Binary and the 1 Binary byte is copied into register X. <br  />
 At the beginning of the macro command the communication buffer contains only the data field of the incoming command. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row68"></a>
<table class="doxtable">
<caption style="text-align:left">Table 68 INCA / DECA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">INCA <br  />
DECA </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of Register A is incremented (INCA) or decremented (DECA). The Register A is considered as a 64 bit unsigned integer. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row69"></a>
<table class="doxtable">
<caption style="text-align:left">Table 69 INCX / DECX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">INCX <br  />
DECX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of Register X is incremented (INCX) or decremented (DECX). The Register X is considered as a 8-bit unsigned integer. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row70"></a>
<table class="doxtable">
<caption style="text-align:left">Table 70 INIT_1DES_DUKPT</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">INIT_1DES_DUKPT </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Initialize Triple DES DUKPT. <ul>
<li>
The Initial Key Serial Number (IKSN) is the first.<br  />
 </li>
<li>
10 bytes (0-9) of the communication buffer.<br  />
 </li>
<li>
The Initial Key (IK) is in B0. </li>
</ul>
</td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 4.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row71"></a>
<table class="doxtable">
<caption style="text-align:left">Table 71 INIT_3DES_DUKPT</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">INIT_3DES_DUKPT </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Initialize Triple DES DUKPT. <ul>
<li>
The Initial Key Serial Number (IKSN) is the first.<br  />
 </li>
<li>
10 bytes (0-9) of the communication buffer.<br  />
 </li>
<li>
The Initial Key Left (IKL) is in B0.<br  />
 </li>
<li>
The Initial Key Right (IKR) is in B </li>
</ul>
</td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 4.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row72"></a>
<table class="doxtable">
<caption style="text-align:left">Table 72 LDA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LDAX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (block location) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>If the content of the block <code>#index</code> is valid (present), then it is copied into register A. If the block is invalid (not been loaded or corrupted), then the macro command execution stops and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row73"></a>
<table class="doxtable">
<caption style="text-align:left">Table 73 LDAI</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LDAI value </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>value (8-byte immediate value) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The 8-byte immediate value is copied into the register A. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row74"></a>
<table class="doxtable">
<caption style="text-align:left">Table 74 LDAX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LAD index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>If the block pointed by the content of register X is valid (present), then it is copied into register A. If the block is invalid (not been loaded or corrupted), then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row75"></a>
<table class="doxtable">
<caption style="text-align:left">Table 75 LDXI</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LDXI value </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>One-byte value </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The immediate value is copied into the single-byte register X. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row76"></a>
<table class="doxtable">
<caption style="text-align:left">Table 76 LENGTH</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LENGTH number </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>number (Number of bytes expected) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction verifies the number of data bytes received in the macro command call. <br  />
 If the length of the data field does not match the number of bytes expected, then the command is not executed and E_VS_BAD_LENGTH error is returned. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This instruction can be used only after MACRO or SID instructions, E_VS_BAD_CHAINING is returned otherwise. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row77"></a>
<table class="doxtable">
<caption style="text-align:left">Table 77 LSLA / LSRA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">LSLA number <br  />
 LSRA number </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>number (Number of bits to be shifted) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of the register A is shifted by number bits to the left (LSLA) or to the right (LSRA). <br  />
 Incoming bits from the left (LSLA) or from the right (LSRA) are 0. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row78"></a>
<table class="doxtable">
<caption style="text-align:left">Table 78 MACRO index</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MACRO index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (Macro command index (command number). Range is [10h..FFh]) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This keyword defines the macro command index that will be used to call this macro. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Commands from 00h to 0Fh are reserved, so the first available value is 10h. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row79"></a>
<table class="doxtable">
<caption style="text-align:left">Table 79 MAC_CB offset length</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MAC_CB offset length </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>MAC the data in the communication buffer starting at offset for length. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Must set or clear IV before the start of MAC. <br  />
 Must select algorithm and then key before execution of OP code. <br  />
 Length must be a multiple of 8 bytes, so data must be padded. <br  />
 Result in IV, all 8 bytes, data is not truncated. <br  />
 This OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row80"></a>
<table class="doxtable">
<caption style="text-align:left">Table 80 MAC_CB_X offset</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MAC_CB_X offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>MAC the data in the communication buffer starting at offset for length in X. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Must set or clear IV before the start of MAC. <br  />
 Must select algorithm and then key before the execution of OP code. <br  />
 Length must be a multiple of 8 bytes, so data must be padded. <br  />
 Result in IV, all 8 bytes, data not truncated. <br  />
 This OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row81"></a>
<table class="doxtable">
<caption style="text-align:left">Table 81 MOV_A_B0 / MOV_A_B1</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_A_B0 <br  />
MOV_A_B1 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of register A is copied into the register B0 or B1. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Content of register A is not modified by this instruction. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row82"></a>
<table class="doxtable">
<caption style="text-align:left">Table 82 MOV_A_IV</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_A_IV </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Set A as IV. The content of register A is copied into the Initialization Vector. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Content of register A is not modified by this instruction. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row83"></a>
<table class="doxtable">
<caption style="text-align:left">Table 83 MOV_A_W</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_A_W </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of register A is copied into register W. Only the first 8 bytes of register W are modified. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Content of register A is not modified by this instruction. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row84"></a>
<table class="doxtable">
<caption style="text-align:left">Table 84 MOV_A_X</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_A_X </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The first byte of register A is copied into the single-byte register X. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Content of register A is not modified by this instruction. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row85"></a>
<table class="doxtable">
<caption style="text-align:left">Table 85 MOV_B0_A / MOV_B1_A</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_B0_A <br  />
MOV_B1_A </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of register B0 or B1 is copied into register A. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>Content of register B0 and B1 is not modified by this instruction. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row86"></a>
<table class="doxtable">
<caption style="text-align:left">Table 86 MOV_IV_A</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_IV_A </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Get IV into A. <br  />
 If ALGO_DES56 (default) is selected, then the Initialization Vector 0 (IV-0) is copied into the register A. Otherwise, the Initialization Vector 0 (IV-0) is copied into the register A and the Initialization Vector 1 (IV-1) is copied into the register B0. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>The behavior of this instruction depends on the selected algorithm. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row87"></a>
<table class="doxtable">
<caption style="text-align:left">Table 87 MOV_IW_A</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_IW_A </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The first 8 bytes of register W are copied into register A. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row88"></a>
<table class="doxtable">
<caption style="text-align:left">Table 88 MOV_X_A</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">MOV_X_A </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The single-byte register X is copied into the first byte of register A. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row89"></a>
<table class="doxtable">
<caption style="text-align:left">Table 89 OAEP</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">OAEP </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Encode message M in register W, result EM in register W. <br  />
 Decode message EM in register W, result M in register W. <br  />
 From RFC 8017 - PKCS <code>#1</code> v2.2 Section 7.1 RSAES-OAEP. <a href="https://tools.ietf.org/html/rfc8017">https://tools.ietf.org/html/rfc8017</a> <br  />
 <b>Input: </b><br  />
 CB - optional label L <br  />
 Register X - 1 - Encode, 0 - Decode <br  />
 Register W - Message M or Encoded Message EM <br  />
 Register A - OAEP options and lengths <br  />
 <br  />
 <small>Register A Byte 0 Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7</small><br  />
<br  />
 Byte 0 Hash <br  />
 Value Hash <br  />
 0 SHA1 <br  />
 1 SHA256 <br  />
 <br  />
 Byte 1 MGF <br  />
 Value MGF <br  />
 0 SHA1 <br  />
 1 SHA256 <br  />
 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td><ul>
<li>
Bytes 2 and 3 Length of optional label L. Valid length 0 (no label provided) to 521 bytes (Max CB length) </li>
<li>
Bytes 4 and 5 Length of Output for Encode or Length of Input for Decode - k. Valid length &gt;= 128 and &lt;= 256 bytes </li>
<li>
Bytes 6 and 7 Input for Encode only. Length of Message M (mLen) in bytes. Valid length &lt;= k - 2hLen - 2 </li>
</ul>
<br  />
 <table class="doxtable">
<tr>
<td>Valid Length of M (mLen) in bytes </td><td>Length of Output in bytes </td><td>Hash </td></tr>
<tr>
<td>mLen &lt;= k - 2hLen - 2 </td><td>k </td></tr>
<tr>
<td>This will be variable based on k <br  />
Below are min and max Examples </td><td>Min and max values </td><td></td></tr>
<tr>
<td>1 to 86 (128 - (2*20) - 2) </td><td>128 </td><td>SHA1 </td></tr>
<tr>
<td>1 to 62 (128 - (2*32) - 2) </td><td>128 </td><td>SHA256 </td></tr>
<tr>
<td>1 to 214 (256 - (2*20) - 2) </td><td>256 </td><td>SHA1 </td></tr>
<tr>
<td>1 to 190 (256 - (2*32) - 2) </td><td>256 </td><td>SHA256 </td></tr>
</table>
<br  />
 <b>Output:</b><br  />
 Register W - OAEP Encoded Message EM <br  />
 OAEP Decoded Message M <br  />
 Register A - Output for Decode only. Bytes 6 and 7 - Length of Decoded Message M <br  />
 <b>NOTE:</b> This OP code is only available in version 7.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row90"></a>
<table class="doxtable">
<caption style="text-align:left">Table 90 OFFSET0 (A-B0 mod 10)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">OFFSET0 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Performs the following operation on each nibble of register A (Register B0 contains the value to be subtracted):<br  />
 A &lt;- (A-B0) mod 10 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Reg B: 12 34 00 00 00 50 00 09<br  />
 Reg A Before: 99 99 00 00 00 60 00 01<br  />
 Reg A After: 87 65 00 00 00 10 00 02 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row91"></a>
<table class="doxtable">
<caption style="text-align:left">Table 91 OFFSET1 (CCV type 1)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">OFFSET1 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Performs the following operation on each nibble of register A (Register B0 contains the value to be added):<br  />
 A &lt;- (A+B0) mod 10 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Reg B: 12 34 00 00 00 50 00 09<br  />
 Reg A Before: 99 99 00 00 00 60 00 01<br  />
 Reg A After: 01 23 00 00 00 10 00 90 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row92"></a>
<table class="doxtable">
<caption style="text-align:left">Table 92 OFFSET2 (CCV type 2)</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">OFFSET2 (CCV type 2) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Performs the following operation on each 4-digit pieces of register A (Register B0 contains the value to be added):<br  />
 A &lt;- (A+B0) mod 10000 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Example </td><td>Reg B: 12 34 00 00 00 50 00 09<br  />
 Reg A Before: 99 99 00 00 00 60 00 01<br  />
 Reg A After: 12 33 00 00 01 10 01 00 </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row93"></a>
<table class="doxtable">
<caption style="text-align:left">Table 93 RNDW</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">RNDW </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction fills W with random bytes. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 2.0 of the VSS interpreter of higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row94"></a>
<table class="doxtable">
<caption style="text-align:left">Table 94 RSACOMP</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">RSACOMP </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Performs an RSA computation on the data in register W, then using the RSA key currently selected. Result is in register W. The size of the data being processed from the register W is equal to the size of the modulus of the RSA key selected. This OP code has the following limitations: <ul>
<li>
The size of the modulus for the SC 5000 must be at least 8 bytes, multiple of 4 bytes. For other devices, see the programmer reference manual. </li>
<li>
For the EMV key slots the maximum size of the modulus is 252 bytes and the maximum size of the exponent is 3 bytes. </li>
</ul>
If those limitations are not respected or if an RSA key slot has not been selected, then the macro execution stops, and an error code is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row95"></a>
<table class="doxtable">
<caption style="text-align:left">Table 95 SELECT</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SELECT index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (Key block number. Must be in the range defined by keyword DEF_BLK.) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>If ALGO_DES56t key register CK-0 is used. If ALGO_DES112 or ALGO_AES128 is selected, then the content of key blocks <code>#index</code> and <code>#index+1</code> are copied into current key registers CK-0 and CK-1.<br  />
 If ALGO_DES168 or ALGO_AES192 is selected, then the content of key blocks <code>#index</code>, <code>#index+1</code> and <code>#index+2</code> are copied into current key registers CK- 0, CK-1 and CK-2.<br  />
 If ALGO_AES256 is selected, then the content of key blocks <code>#index</code>, <code>#index+1</code>, <code>#index+2</code> and <code>#index+3</code> are copied into current key registers CK-0, CK-1, CK-2 and CK-3. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>If index is out of range or the key(s) is (are) not present in the block(s), an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row96"></a>
<table class="doxtable">
<caption style="text-align:left">Table 96 SELECTA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SELECT index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>If ALGO_DES56 (default) is selected, then the content of register A is copied into current key register CK-0. <br  />
 If ALGO_DES112 or ALGO_AES128 is selected, then the content of register A and B0 are copied into current key registers CK- 0 and CK-1. <br  />
 If ALGO_DES168 or ALGO_AES192 is selected, then the content of register A, B0 and B1 are copied into current key registers CK-0, CK-1 and CK-2. <br  />
 If ALGO_AES256 is selected, this instruction does nothing: In that case, each part of the key must be into key slots and then transferred into CK-n using the SELECT command. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row97"></a>
<table class="doxtable">
<caption style="text-align:left">Table 97 SELECTX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SELECTX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>If ALGO_DES56 (default) is selected, then the content of the block pointed by register X is copied into current key register CK-0. <br  />
 If ALGO_DES112 or ALGO_AES128 is selected, the content of the block pointed by register X plus the next block are copied into current key registers CK-0 and CK-1. <br  />
 If ALGO_DES168 or ALGO_AES192 is selected, the content of the block pointed by register X plus the next two blocks are copied into current key registers CK-0, CK-1 and CK-2. <br  />
 If ALGO_AES256 is selected, then the content of the block pointed by register X plus the next three blocks are copied into current key registers CK-0, CK-1, CK-2 and CK-3. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row98"></a>
<table class="doxtable">
<caption style="text-align:left">Table 98 SELRSA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SELRSA </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (RSA key slot number, Range [0..5]) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Select the key in RSA key slot <code>#index</code> for the next RSA computation. <br  />
 If the index is out of range, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row99"></a>
<table class="doxtable">
<caption style="text-align:left">Table 99 SELRSAX</caption>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td width="1000">none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Select the key in the slot pointer by register X for the next RSA computation. <br  />
 If the index value in register X is out of range (&gt;5) or the key is not present, the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row100"></a>
<table class="doxtable">
<caption style="text-align:left">Table 100 SENDA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SENDA offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (position in the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The 8 bytes of register A are copied into the communication buffer starting at the position offset. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row101"></a>
<table class="doxtable">
<caption style="text-align:left">Table 101 SENDA_BIN_TO_HA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SENDA_BIN_TO_HA offset <br  />
 length (number of bytes) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (position in the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>length bytes from W are converted from Binary to Hex ASCII (‘0’-‘9’, ‘A’-‘F’) and length*2 bytes are copied into the communication buffer starting at the position offset. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row102"></a>
<table class="doxtable">
<caption style="text-align:left">Table 102 SENDW</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SELRAX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Select the key in the slot pointer by register X for the next RSA computation.<br  />
 If the index value in register X is out of range (&gt;5) or the key is not present, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row103"></a>
<table class="doxtable">
<caption style="text-align:left">Table 103 SENDX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SENDX offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (position in the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of register X is copied into the communication buffer at the position offset. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row104"></a>
<table class="doxtable">
<caption style="text-align:left">Table 104 SENDX_BIN_TO_HA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SENDX_BIN_TO_HA offset </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>offset (position in the communication buffer) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>1 byte from register X is converted from Binary to Hex ASCII (‘0’-‘9’, ‘A’-‘F’) and the 2 bytes are copied into the communication buffer starting at the position offset. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row105"></a>
<table class="doxtable">
<caption style="text-align:left">Table 105 SHAINIT / SHA256INIT</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SHAINIT / SHA256INIT </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction initiates the SHA-1 / SHA-256 computation. It initializes the SHA context. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>SHA256INIT OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row106"></a>
<table class="doxtable">
<caption style="text-align:left">Table 106 SHATERM / SHA256TERM</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SHATERM / SHA256TERM </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction finalizes the SHA-1 / SHA-256 computation with the remaining data and padding. The 20-byte SHA or the 32-byte SHA256 result is copied into register W. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>SHA256TERM OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row107"></a>
<table class="doxtable">
<caption style="text-align:left">Table 107 SHAUPDATE / SHA256UPDATE</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SHAUPDATE / SHA256UPDATE </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>length (Number of bytes to process) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Update SHA-1 / SHA-256 with length bytes from register W. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>The SHA-1 / SHA-256 is byte-oriented and does not handle bit streams. <br  />
 SHA256UPDATE OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row108"></a>
<table class="doxtable">
<caption style="text-align:left">Table 108 SID</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">SID current next error </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>current (Value of the Current State Identifier (CSID)) <br  />
 next (Value of the Next State Identifier (NSID)) <br  />
 error (Value of the Error State Identifier (ESID)) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The instruction first verifies that the internal State Identifier (SID) matches the current value (CSID). <br  />
 If not, meaning this macro cannot be called at that point, an E_VS_BAD_CHAINING error is returned (the internal SID is not modified.) <br  />
 If the values match, then the macro command is executed. <br  />
 If the execution fails (ExecuteScript() return code &gt; 0), then the internal SID is set to the error value (ESID). <br  />
 If the execution is successful, then the internal SID is set to the next value (NSID). </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This instruction must be used at the beginning of a macro, right after a MACRO or LENGTH keyword. <br  />
 If the ExecuteScript() function ends due to an error other than an execution error (negative error code) then the SID is not modified. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row109"></a>
<table class="doxtable">
<caption style="text-align:left">Table 109 STA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">STA index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of register A is copied into block <code>#index</code>. The block is then marked as valid. <br  />
 If the index is out of range, then the macro execution stops, and an error code is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row110"></a>
<table class="doxtable">
<caption style="text-align:left">Table 110 STAX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">STAX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The content of register A is copied into the block pointed by the content of register X. The block is then marked as valid. <br  />
 If the value in register X is out of range, then the macro execution stops, and an error code is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row111"></a>
<table class="doxtable">
<caption style="text-align:left">Table 111 STRSA</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">STRSA index </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>index (RSA key location, Range [0..5]) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The RSA key in register W is copied into the key slot <code>#index</code>. Key slots <code>#0</code> through <code>#3</code> are the EMV key slots shared with the EMV module. Those shared key slots have the following limitations: <ul>
<li>
Size of exponent limited to 3 bytes </li>
<li>
Size of modulus limited to 252 bytes </li>
</ul>
Key slots <code>#4</code> and <code>#5</code> are two additional key slots that allow private key computations up to 2048 bits (256 bytes) on versions older than 9.1 and up to 4096 bits (512 bytes) starting with VSS version 9.1. The contents of register W needs to be formatted as follows: <br  />
<b>RSA 2048-and EMV keys:</b> <ul>
<li>
byte <code>#0:</code> Key type - EMV value or 0 for RSA-2048 </li>
<li>
byte <code>#1..5:</code> RID (relevant for EMV keys only) </li>
<li>
byte <code>#6:</code> Key index (relevant for EMV keys only) </li>
<li>
byte <code>#7:</code> Modulus length (use value 0 for 2048-bit modulus) </li>
<li>
byte <code>#8:</code> Exponent length (use value 0 for 2048-bit private exponent) </li>
<li>
byte <code>#9..x:</code> Modulus </li>
<li>
byte <code>#(9+x)..y:</code> Exponent </li>
</ul>
<b>RSA-4096 and RSA-3072 keys:</b> <ul>
<li>
byte <code>#0:</code> Key type, 1 for 4096-bit keys </li>
<li>
byte <code>#1..5:</code> RID (relevant for EMV keys only) </li>
<li>
byte <code>#6:</code> Key index (relevant for EMV keys only) </li>
<li>
byte <code>#7:</code> Modulus length byte 1 </li>
<li>
byte <code>#8:</code> Modulus length byte 2 </li>
<li>
byte <code>#9:</code> Exponent length byte 1 </li>
<li>
byte <code>#10:</code> Exponent length byte 2 </li>
<li>
byte <code>#11..x:</code> Modulus </li>
<li>
byte <code>#(11+x)..y:</code> Exponent </li>
</ul>
For 4096-bit and 3072-bit keys modulus and exponent length should be passed as a two byte big endian value (see <a class="el" href="vss_documentation.html#subsubsec_vss_macro_command_script_examples">Script examples</a>). If the index is out of range, then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row112"></a>
<table class="doxtable">
<caption style="text-align:left">Table 112 STRSAX</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">STRSAX </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>none </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The RSA key in register W is copied into the key slot pointed by register X. Refer to instruction STRSA for details. <br  />
 If the index value in register Xis out of range (&lt;5), then the macro command execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row113"></a>
<table class="doxtable">
<caption style="text-align:left">Table 113 STSHA / STSHA256</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">STSHA / STSHA256 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>The first 20 bytes of SHA or the first 32 bytes of SHA256 of register W are copied into the SHA register. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>STSHA256 OP code is only available in version 6.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row114"></a>
<table class="doxtable">
<caption style="text-align:left">Table 114 TSTXI</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">TSTXI min max </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>min (minimum acceptable value) <br  />
max (maximum acceptable value) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction verifies the value contained in the index register X. <br  />
 If the value is in the range [min..max], nothing is done and the next instruction is processed. <br  />
 If not in the range, then the macro execution stops, and an error is returned (see <a class="el" href="vss_documentation.html#sec_vss_appendix_a">Appendix A: OP Code Table</a>). </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row115"></a>
<table class="doxtable">
<caption style="text-align:left">Table 115 TSTXI_BOR</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">TSTXI_BOR min max Label </td></tr>
<tr>
<td style="background-color:#D6EAF8">Parameters </td><td>min (minimum acceptable value) <br  />
max (maximum acceptable value) <br  />
Label (Label to branch to) </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>This instruction verifies the value contained in the index register X. <br  />
 If the value is in the range [min..max], nothing is done, and the next instruction is processed. <br  />
 If out of range, then a branch is made to Label. </td></tr>
<tr>
<td style="background-color:#D6EAF8">Comments </td><td>This OP code is only available in version 2.0 of the VSS interpreter and higher. </td></tr>
</table>
<p><br  />
</p>
<a class="anchor" id="multi_row116"></a>
<table class="doxtable">
<caption style="text-align:left">Table 116 XORA_B0 / XORA_B1 / ANDA_B0 / ANDA_B1 / ORA_B0 / ORA_B1</caption>
<tr>
<td style="background-color:#D6EAF8" width="80">Format </td><td width="1000">XORA_B0 <br  />
XORA_B1 <br  />
ANDA_B0 <br  />
ANDA_B1 <br  />
ORA_B0 <br  />
ORA_B1 </td></tr>
<tr>
<td style="background-color:#D6EAF8">Operation </td><td>Those instructions perform logical operations on register A using data in register B0 or B1. Result in register A. Content of register B0 or B1 is not modified by those instructions. </td></tr>
</table>
<p><br  />
</p>
<h3><a class="anchor" id="subsubsec_vss_macro_command_restrictionr"></a>
Restrictions</h3>
<p>Following are the rules that should be followed while writing the script:</p>
<ul>
<li>The script must start with the keywords SCRIPT and SUBDEV.</li>
<li>Then must follow the block definition section with the keywords DEF_BLK or RETAIN_BLK, but not both.</li>
<li>Some blocks may then be loaded with values using the keyword LD_BLK.</li>
<li>The restrictions keywords (MS_OFF and DUKPT_OFF) are optional and can be used right before the block definition.</li>
<li>The macro definition section is optional. We can imagine a script used only to disable the PP1000 mode. Such a script would be 4 line long:</li>
<li>SCRIPT TEST0001</li>
<li>SUBDEV 7</li>
<li>PP1000_OFF</li>
<li>DEF_BLK 0 0</li>
<li>Each macro definition must start with MACRO and end with EOM.</li>
<li>The keywords LENGTH and SID are optional and if used must be placed right after the keyword MACRO.</li>
<li>The low-level instruction keywords can only be used inside a macro.</li>
<li>The script file must end after the block definition section or after EOM.</li>
<li>Comments must start with ‘//’. The tool ignores all following characters in the line.</li>
<li>Blank lines are ignored. They do not generate an error.</li>
<li>By default, values are assumed to be decimal. 0x?? and ??h notations may be used to specify hexadecimal values, and ??b for binary values. Therefore, all the following notations are equivalent: 18, 0x012, 00000012h, 010010b, 12h.</li>
<li>The format of branching instructions: BRA LABEL LABEL: Branching can only be done to labels within the macros containing the branch instruction. Labels only need to be unique within a macro.</li>
</ul>
<h3><a class="anchor" id="subsubsec_vss_macro_command_chaining_mechanism"></a>
Chaining Mechanism</h3>
<p>The chaining mechanism enforces the execution of the macro commands in a predefined order. Technically, this is done using an internal variable called the State IDentifier (SID).</p>
<p>The SID is a 2-byte value indicating the number of the next command. All other macro commands will be rejected. Three values are stored along with each macro:</p>
<ul>
<li>The Current State Identifier (CSID). It should match with the internal SID when the macro is executed.</li>
<li>The Next Command Identifier (NSID). It will be the new value of the internal SID after a successful execution of the macro. The NSID of the current command must equal the CSID of the following command.</li>
<li>The Error State Identifier (ESID). It will be the new value of the internal SID if an error occurs during the execution of the macro.</li>
</ul>
<p>Following are some rules that apply to the chaining mechanism:</p>
<ul>
<li>The internal SID is reset to 0000h at start-up.</li>
<li>The CSID must be equal to the NSID of the previous command.</li>
<li>Several commands may have the same CSID.</li>
<li>Several commands may have the same NSID.</li>
<li>Commands that have CSID = FFFFh may be executed any time.</li>
<li>Commands that have NSID = FFFFh permit the execution of any next command.</li>
<li>A command should not have CSID = NSID because this opens the way for building new commands.</li>
</ul>
<p>In most of the cases the macro commands will perform high-level operations and will not need any chaining. They will ideally start and finish with the same SID (equals to 0), that is the order of execution is not important. If the SID values are not specified in the macro definition, then by default, no chaining is enforced for 0000h.</p>
<h3><a class="anchor" id="subsubsec_vss_macro_command_audit"></a>
Audit</h3>
<p>It is the responsibility of the authority signing the macros (the Sponsor) to verify that a sufficient security level is reached. The audit will be performed on the script file but only the downloadable file will be signed. It means that the script processing and the signing must be performed by the same person using genuine tools to prevent file switching.</p>
<h3><a class="anchor" id="subsubsec_vss_macro_command_script_examples"></a>
Script Examples</h3>
<p><b>IBM 3624 with offset offline PIN verification</b></p>
<p>The following script defines two additional blocks to store the double-length PVK. The key is loaded using the generic key loading functions.</p>
<ul>
<li>Set <code>#00h / Key#00h</code> -&gt; PVKL</li>
<li>Set <code>#00h / Key#01h</code> -&gt; PVKR</li>
</ul>
<p>The Security Script also implements a single macro command for the PIN verification.</p>
<p>Script Example for IBM 3624 with offset offline PIN verification: </p><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">SUBDEV 00h  <span class="comment">// Script Identifier (Sub-device #)</span></div>
<div class="line">SCRIPT PVV0001  <span class="comment">// Name for the IBM3624 Security Script</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">DEF_BLK 2 2 <span class="comment">// Define 2 8-byte blocks for PVK storage. PVK is loaded</span></div>
<div class="line">        <span class="comment">//  using the default key loading functions.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 10h   <span class="comment">// IBM3624OFFSET offline PIN verification</span></div>
<div class="line">LENGTH 24   <span class="comment">// 8-byte PAN + 8-byte Decimalization Table +</span></div>
<div class="line">        <span class="comment">//              8-byte RRV|000000000000</span></div>
<div class="line">GETA 08h    <span class="comment">// copy the decimalization table into A</span></div>
<div class="line">MOV_A_B0    <span class="comment">// then into B0</span></div>
<div class="line">GETA 00h    <span class="comment">// copy the PAN into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select PVKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">SELECT 01h  <span class="comment">// select PVKR</span></div>
<div class="line">DECB        <span class="comment">// ECB DES decryption, result into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select PVKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">DECIM1      <span class="comment">// perform the decimalization of A using the table B0</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store the 8-byte result into B0</span></div>
<div class="line">LDAI FFFF000000000000</div>
<div class="line">ANDA_B0     <span class="comment">// keep only the first 4 digits</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store “true PIN” into B0</span></div>
<div class="line">CLRA</div>
<div class="line">GETPIN0     <span class="comment">// get PIN digits into A</span></div>
<div class="line">OFFSET0     <span class="comment">// subtract the “true PIN” from the customer PIN</span></div>
<div class="line">MOV_A_B0    <span class="comment">//  store CRV into B0</span></div>
<div class="line">GETA 10h    <span class="comment">// copy RRV into A</span></div>
<div class="line">CMPA_B0     <span class="comment">// compare CRV and RRV, exit on error if different</span></div>
<div class="line">EOM 00h     <span class="comment">// return no data but the status=0 (successful execution)</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --><p><b>PVV offline PIN verification</b></p>
<p>Let’s assume we have a macro command to load the PVK (simple or double length) in blocks <code>#00</code> and <code>#01</code>. Here are the macros performing the PIN verification using the simple and double length keys:</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 13h   <span class="comment">// PVV offline PIN verification (simple DES)</span></div>
<div class="line">LENGTH 10   <span class="comment">// 2 NULL bytes + 6-Byte PAN|PVKI + 2-byte PVV</span></div>
<div class="line">GETA 00h    <span class="comment">// copy the 0000|PAN|PVKI into A</span></div>
<div class="line">GETPIN1     <span class="comment">// get PIN digits into A (from the right)</span></div>
<div class="line">SELECT 00h  <span class="comment">// select PVKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">DECIM0      <span class="comment">// perform the decimalization of A (PVV algorithm)</span></div>
<div class="line">MOV_A_B0    <span class="comment">//  store PCV into B0</span></div>
<div class="line">GETA 08h    <span class="comment">// copy PVV into A</span></div>
<div class="line">CMPA_B0     <span class="comment">// compare PCV and PVV, exit on error if different</span></div>
<div class="line">EOM 00h     <span class="comment">// return no data but the status=0 (successful execution)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 14h   <span class="comment">// PVV offline PIN verification (triple DES)</span></div>
<div class="line">LENGTH 10   <span class="comment">// 2 NULL bytes + 6-Byte PAN|PVKI + 2-byte PVV</span></div>
<div class="line">GETA 00h    <span class="comment">// copy the 0000|PAN|PVKI into A</span></div>
<div class="line">GETPIN1     <span class="comment">// get PIN digits into A (from the right)</span></div>
<div class="line">SELECT 00h  <span class="comment">// select PVKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">SELECT 01h  <span class="comment">// select PVKR</span></div>
<div class="line">DECB        <span class="comment">// ECB DES decryption, result into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select PVKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">DECIM0      <span class="comment">// perform the decimalization of A (PVV algorithm)</span></div>
<div class="line">MOV_A_B0    <span class="comment">//  store PCV into B0</span></div>
<div class="line">GETA 08h    <span class="comment">// copy PVV into A</span></div>
<div class="line">CMPA_B0     <span class="comment">// compare PCV and PVV, exit on error if different</span></div>
<div class="line">EOM 00h     <span class="comment">// return no data but the status=0 (successful execution)</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --><p><b>PAC Shell offline PIN verification</b></p>
<p>We will assume the PAC Key location is block <code>#02</code>. Here is the macro for the PIN verification:</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 15h   <span class="comment">// PAC SHELL offline PIN verification</span></div>
<div class="line">LENGTH 24   <span class="comment">// 8-byte PAN|0000 + 8-byte PinOffset|000000000000 +</span></div>
<div class="line">CLRA        <span class="comment">//          8-byte refPAC|0000000000000</span></div>
<div class="line">GETPIN0     <span class="comment">// get PIN digits into A (from the left)</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store customer PIN into B0</span></div>
<div class="line">GETA 08h    <span class="comment">// copy PinOffset|000000000000 into A</span></div>
<div class="line">OFFSET0     <span class="comment">// subtract the customer PIN from the PIN offset</span></div>
<div class="line">LSRA 30h    <span class="comment">// right justify the “derived PIN” and pad with 0</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store the “derived PIN” into B0</span></div>
<div class="line">GETA 00h    <span class="comment">// copy PAN|0000 into A</span></div>
<div class="line">ORA_B0      <span class="comment">// concatenate PAN and the “derived PIN”</span></div>
<div class="line">SELECT 02h  <span class="comment">// select PAC KEY</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">DECIM0      <span class="comment">// perform the decimalization of A (PAC shell algo)</span></div>
<div class="line">MOV_A_B0    <span class="comment">//  store calcPAC into B0</span></div>
<div class="line">GETA 10h    <span class="comment">// copy referencePAC into A</span></div>
<div class="line">CMPA_B0     <span class="comment">// compare PACs, exit on error if different</span></div>
<div class="line">EOM 00h     <span class="comment">// return no data but the status=0 (successful execution)</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>- in this example the selection functions have to be implemented in the terminal. Only the selected fields are sent to the PINpad instead of the full Track 2 data.</dd></dl>
<p><b>CCV Shell offline PIN verification</b></p>
<p>Assuming the Cross-Domain Key is in the block <code>#03</code>, here is the macro for the PIN verification. Actually, this macro needs to be duplicated two more times in order to support all three types of the offset functions. Only the OFFSETx line will change.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 16h   <span class="comment">// CCV offline PIN verification (offset type 0)</span></div>
<div class="line">LENGTH 0018h    <span class="comment">// 8-byte IKCfields + 8-byte PinOffset|000000000000</span></div>
<div class="line">GETA 00h    <span class="comment">// copy selected card data (I, K and C fields) into A</span></div>
<div class="line">SELECT 03h  <span class="comment">// select Cross Domain Key</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">DECIM2      <span class="comment">// perform the decimalization of A (CCV algorithm)</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store the “derived PIN” into B0</span></div>
<div class="line">GETA 08h    <span class="comment">// copy PinOffset|000000000000 into A</span></div>
<div class="line">OFFSET0     <span class="comment">// subtract the “derived PIN” from the PIN offset</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store the calculated PIN into B0</span></div>
<div class="line">CLRA</div>
<div class="line">GETPIN0     <span class="comment">// get PIN digits into A (from the left)</span></div>
<div class="line">CMPA_B0     <span class="comment">// compare PINs, exit on error if different</span></div>
<div class="line">EOM 00h     <span class="comment">// return no data but the status=0 (successful execution)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --><p><b>Interac Scheme for Canada</b></p>
<p>This example has been moved to a specific document: VeriShield Security Script for CIBC version 1.0.</p>
<p><b>APACS40 for Poland</b></p>
<p>The analysis below is based on the SPRD of SC552 CROATIA that is compliant with the APACS40 standard.</p>
<p>The Security Script implementation given here is intended to demonstrate the capability to support the APACS40 requirements and should not be considered as the exact final command flow.</p>
<p><em>1 - Key injection with mutual authentication.</em></p>
<p>Assumption: MLK is loaded in blocks <code>#00</code> and <code>#01</code> and we can load any key from block <code>#00</code> to <code>#04</code> (MLKL,MLKR, SK, SRKL, SRKR). We will use two macros and chain them together.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 10h   <span class="comment">// Authentication step 1</span></div>
<div class="line">SID 0000h 2568h 0000h <span class="comment">// set SID to 2568 on successful completion</span></div>
<div class="line">LENGTH 0008h    <span class="comment">// 8-byte random from the host (RNDh)</span></div>
<div class="line">GETA 00h    <span class="comment">// copy the random into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select MLKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">SELECT 01h  <span class="comment">// select MLKR</span></div>
<div class="line">DECB        <span class="comment">// ECB DES decryption, result into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select MLKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">LSRA 28h    <span class="comment">//</span></div>
<div class="line">LSLA 28h    <span class="comment">// keep only the first 3 bytes</span></div>
<div class="line">SENDA 00    <span class="comment">// copy the result into the communication buffer</span></div>
<div class="line">RNDA        <span class="comment">// generate a random into A (RNDs)</span></div>
<div class="line">SENDA 03h   <span class="comment">// copy RNDs into the communication buffer</span></div>
<div class="line">MOV_A_IV    <span class="comment">// save A into IV (IV content is retained after EOM)</span></div>
<div class="line">EOM 0Bh     <span class="comment">// return 11 bytes (3RESs + RNDs)</span></div>
<div class="line"> </div>
<div class="line">The host verifies the cryptogram computed by the PINpad.</div>
<div class="line">The host sends a cryptogram based on the PINpad’s random number</div>
<div class="line"> </div>
<div class="line">MACRO 11h   <span class="comment">// Authentication step 2 + Key loading</span></div>
<div class="line">SID 2568h 0000h 0000h <span class="comment">// executable only if SID is 2568</span></div>
<div class="line">LENGTH 000Ch    <span class="comment">// 3-byte cryptogram (3RESh) + Key Index + 8-byte CMKEY</span></div>
<div class="line">GETX 03h    <span class="comment">// copy the Key Index into Index Register X</span></div>
<div class="line">TSTXI 00h 04h   <span class="comment">// verify that the Key Index is in the range [20..24]</span></div>
<div class="line">MOV_IV_A    <span class="comment">// retrieve RNDs from IV</span></div>
<div class="line">CLRIV       <span class="comment">// clear IV</span></div>
<div class="line">SELECT 00h  <span class="comment">// select MLKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">SELECT 01h  <span class="comment">// select MLKR</span></div>
<div class="line">DECB        <span class="comment">// ECB DES decryption, result into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select MLKL</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">LSRA 28h    <span class="comment">//</span></div>
<div class="line">LSLA 28h    <span class="comment">// keep only the first 3 bytes</span></div>
<div class="line">MOV_A_B0    <span class="comment">// save the computed value into B0 for comparison</span></div>
<div class="line">GETA 00h    <span class="comment">// copy 3RESs into A</span></div>
<div class="line">LSRA 28h    <span class="comment">// keep only the</span></div>
<div class="line">LSLA 28h    <span class="comment">//        first 3 bytes</span></div>
<div class="line">CMPA_B0     <span class="comment">// compare the cryptograms, exit if it fails</span></div>
<div class="line">GETA 04h    <span class="comment">// copy CMKEY into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select MLKL</span></div>
<div class="line">DECB        <span class="comment">// ECB DES decryption, result into A</span></div>
<div class="line">SELECT 01h  <span class="comment">// select MLKR</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">SELECT 00h  <span class="comment">// select MLKL</span></div>
<div class="line">DECB        <span class="comment">// ECB DES decryption, result into A</span></div>
<div class="line">STAX        <span class="comment">// store MKEY into the location pointed by X</span></div>
<div class="line">EOM 00h     <span class="comment">// the end - nothing to return</span></div>
</div><!-- fragment --><p><em>2 - Derivation of the transaction keys:</em></p>
<p>Assumption: Transaction Key Register (TKR) is in block <code>#05</code>, PIN KEY in block <code>#06</code> and MAC KEY in block <code>#07</code>.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 12h   <span class="comment">// Key Derivation</span></div>
<div class="line">LENGTH 0020h    <span class="comment">// 4 8-byte fields: B|A, A|B, A|C and B|D</span></div>
<div class="line">LDAI B5E37FC5D4F7A393   <span class="comment">// this is the fixed value Y</span></div>
<div class="line">MOV_A_B1    <span class="comment">// store value Y into B1</span></div>
<div class="line">LDA 05h     <span class="comment">// copy TKR into A</span></div>
<div class="line">XORA_B1     <span class="comment">// XOR TKR with value Y</span></div>
<div class="line">MOV_A_B1    <span class="comment">// store the derived TKR into B1</span></div>
<div class="line">SELECTA     <span class="comment">// and also select it for the next computation</span></div>
<div class="line">LDAI A5C7B2828476A829   <span class="comment">// this is the fixed value X</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store value X into B0</span></div>
<div class="line">GETA 00h    <span class="comment">// copy field B|A into A</span></div>
<div class="line">XORA_B0     <span class="comment">// and XOR it with value X</span></div>
<div class="line">MOV_A_B0    <span class="comment">// save the result of the XOR into B0</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">XORA_B0     <span class="comment">// XOR it with the input data - End of the OWF</span></div>
<div class="line">STA 07h     <span class="comment">// This is MAC KEY, store it in block #07</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">LDAI A5C7B2828476A829   <span class="comment">// this is the fixed value X</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store value X into B0</span></div>
<div class="line">GETA 08h    <span class="comment">// copy field A|B into A</span></div>
<div class="line">XORA_B0     / and XOR it with <a class="code" href="_web_service_wrappers_8c.html#a6e248376c0290338633d8137822eb209">value</a> X</div>
<div class="line">MOV_A_B0    <span class="comment">// save the result of the XOR into B0</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">XORA_B0     <span class="comment">// XOR it with the input data - End of the OWF</span></div>
<div class="line">XORA_B1     <span class="comment">// XOR KEYVAL with value Y</span></div>
<div class="line">MOV_A_B0    <span class="comment">// store result into B0</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">GETA 10h    <span class="comment">// copy field A|C into A</span></div>
<div class="line">XORA_B1     <span class="comment">// and XOR it with value Y</span></div>
<div class="line">SELECTA     <span class="comment">// and select it for the next computation</span></div>
<div class="line">LDAI A5C7B2828476A829   <span class="comment">// this is the fixed value X</span></div>
<div class="line">MOV_A_B1    <span class="comment">// store value X into B1</span></div>
<div class="line">GETA 18h    <span class="comment">// copy field B|D into A</span></div>
<div class="line">XORA_B1     <span class="comment">// and XOR it with value X</span></div>
<div class="line">MOV_A_B1    <span class="comment">// save the result of the XOR into B1</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">XORA_B1     <span class="comment">// XOR it with the input data - End of the OWF</span></div>
<div class="line">MOV_A_B1    <span class="comment">// this is CARD KEY, store it into B1</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MOV_B0_A    <span class="comment">// retrieve the result of KEYVAL XOR Y</span></div>
<div class="line">SELECTA     <span class="comment">// and select it for the next computation</span></div>
<div class="line">LDAI A5C7B2828476A829   <span class="comment">// this is the fixed value X</span></div>
<div class="line">XORA_B1     <span class="comment">// XOR value X with CARD KEY</span></div>
<div class="line">MOV_A_B1    <span class="comment">// save the result of the XOR into B1</span></div>
<div class="line">EECB        <span class="comment">// ECB DES encryption, result into A</span></div>
<div class="line">XORA_B1     <span class="comment">// XOR it with the input data - End of the OWF</span></div>
<div class="line">STA 06h     <span class="comment">// This is PIN KEY, store it in block #06</span></div>
<div class="line">EOM 00h     <span class="comment">// the end - nothing to return</span></div>
</div><!-- fragment --><p><b>RSA computation</b></p>
<p>The macro <code>#10h</code> loads the RSA key in key slot <code>#4</code>.</p>
<p>The macro <code>#11h</code> selects the key <code>#4</code> and performs the RSA computation.</p>
<p>The two macros are chained.</p>
<p>The format of the input buffer for the macro <code>#10h</code> must be as follows:</p>
<p><b>2048-bit keys:</b></p><ul>
<li>byte 0: Key type, 0 or EMV value</li>
<li>bytes 1..6: Don’t care</li>
<li>byte 7: modulus length in bytes (use 0 for 2048-bit modulus)</li>
<li>byte 8: exponent length in bytes (use 0 for 2048-bit private exponent)</li>
<li>bytes 9..x: the modulus. x = 9+modulus length -1</li>
<li>byte x+1..y:: the exponent. y = 9+modulus length+exponent length-1</li>
</ul>
<p><b>4096-bit and 3072-bit keys:</b></p><ul>
<li>byte 0: Key type, 1</li>
<li>bytes 1..6: Don’t care</li>
<li>byte 7: modulus length byte 1 (02 for 512 bytes)</li>
<li>byte 8: modulus length byte 2 (00 for 512 bytes)</li>
<li>byte 9: exponent length byte 1</li>
<li>byte 10: exponent length byte 2</li>
<li>bytes 11..x: the modulus. x = 11+modulus length -1</li>
<li>byte x+1..y:: the exponent. y = 11+modulus length+exponent length-1</li>
</ul>
<p>The size of the modulus for the SC 5000 must be at least 8 bytes, multiple of 4 bytes. It can be left-padded with zeros if needed. For other devices, see the programmer reference manual.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// CONFIGURATION SECTION</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">SUBDEV 03h      <span class="comment">// Script Identifier (Script Slot #3)</span></div>
<div class="line">SCRIPT RsaTest1     <span class="comment">// Identifier for this test script//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// KEY DEFINITION SECTION</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">DEF_BLK 0 0         <span class="comment">// no block defined</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MACRO COMMAND DEFINITION SECTION</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 10h</div>
<div class="line">SID 0 5692h 0</div>
<div class="line">GETW 0 521</div>
<div class="line">STRSA 4</div>
<div class="line">EOM 0</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 11h</div>
<div class="line">SID 5692h 0 0</div>
<div class="line">SELRSA 4</div>
<div class="line">GETW 0 256</div>
<div class="line">RSACOMP</div>
<div class="line">SENDW 0 256</div>
<div class="line">EOM 256</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --><p><b>Branching macro example</b></p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// CONFIGURATION SECTION</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">SUBDEV 00h      <span class="comment">// Script Identifier (Sub-device #0)</span></div>
<div class="line">SCRIPT Tst0v2op <span class="comment">// Identifier for Test part 0 version 2 OP codes Security Script</span></div>
<div class="line">PP1000_OFF      <span class="comment">// PP1000 commands are disabled</span></div>
<div class="line">MS_OFF          <span class="comment">// Default M/S commands are disabled</span></div>
<div class="line">DUKPT_OFF       <span class="comment">// Default DUKPT commands are disabled</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// KEY DEFINITION SECTION</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">DEF_BLK 28h 0   <span class="comment">// Define 40 (28h) 8-byte blocks. None of them can be loaded</span></div>
<div class="line">                <span class="comment">// using the default key loading commands. CIBC uses a</span></div>
<div class="line">                <span class="comment">// specific key loading scheme.</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">LD_BLK 27h 0123456789ABCDEF     <span class="comment">// Not a secret value. Flag used to indicate</span></div>
<div class="line">                                <span class="comment">// whether the password has been loaded or not.</span></div>
<div class="line">                                <span class="comment">// Right after the script loading, block #27h</span></div>
<div class="line">                                <span class="comment">// is the only valid block.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MACRO COMMAND DEFINITION SECTION</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 16          <span class="comment">// Test BRA</span></div>
<div class="line">LENGTH 0</div>
<div class="line">LDAI 4252412000000000 <span class="comment">// &quot;BRA &quot;</span></div>
<div class="line">SENDA 0</div>
<div class="line">LDAI 5041535300000000 <span class="comment">// &quot;PASS&quot;</span></div>
<div class="line">BRA PASS</div>
<div class="line">LDAI 2A4641494C2A0000 <span class="comment">// &quot;*FAIL*&quot;</span></div>
<div class="line">PASS:</div>
<div class="line">SENDA 4           <span class="comment">// Put PASS/FAIL in Comm Buffer</span></div>
<div class="line">EOM 128           <span class="comment">// Return Results</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">MACRO 17          <span class="comment">// Test CMPA_BEQ index label</span></div>
<div class="line">LENGTH 0</div>
<div class="line">LDAI 4946203D54414B45 <span class="comment">// &quot;IF =TAKE&quot;</span></div>
<div class="line">SENDA 0</div>
<div class="line">LDAI 204252414E434820 <span class="comment">// &quot; BRANCH &quot;</span></div>
<div class="line">SENDA 8</div>
<div class="line">LDAI 123456781234FF78</div>
<div class="line">STA 0</div>
<div class="line">CMPA_BEQ 0 PASS</div>
<div class="line">LDAI 2A4641494C2A0D0A <span class="comment">// &quot;*FAIL*\r\n&quot;</span></div>
<div class="line">BRA <a class="code" href="namespacevfisdi.html#a28287671eaf7406afd604bd055ba4066a936c4a5547a9360243178f726f6b2715">FAIL</a></div>
<div class="line">PASS:</div>
<div class="line">LDAI 5041535320200D0A <span class="comment">// &quot;PASS  \r\n&quot;</span></div>
<div class="line"><a class="code" href="namespacevfisdi.html#a28287671eaf7406afd604bd055ba4066a936c4a5547a9360243178f726f6b2715">FAIL</a>:</div>
<div class="line">SENDA 16           <span class="comment">// Put PASS/FAIL in Comm Buffer</span></div>
<div class="line">LDAI 4946203E20204E4F <span class="comment">// &quot;IF &gt;  NO&quot;</span></div>
<div class="line">SENDA 24</div>
<div class="line">LDAI 204252414E434820 <span class="comment">// &quot; BRANCH &quot;</span></div>
<div class="line">SENDA 32</div>
<div class="line">LDAI 123456781234FF79</div>
<div class="line">CMPA_BEQ 0 FAIL1</div>
<div class="line">LDAI 5041535320200D0A <span class="comment">// &quot;PASS  \r\n&quot;</span></div>
<div class="line">BRA PASS1</div>
<div class="line">FAIL1:</div>
<div class="line">LDAI 2A4641494C2A0D0A <span class="comment">// &quot;*FAIL*\r\n&quot;</span></div>
<div class="line">PASS1:</div>
<div class="line">SENDA 40           <span class="comment">// Put PASS/FAIL in Comm Buffer</span></div>
<div class="line">LDAI 4946203C20204E4F <span class="comment">// &quot;IF &lt;  NO&quot;</span></div>
<div class="line">SENDA 48</div>
<div class="line">LDAI 204252414E434820 <span class="comment">// &quot; BRANCH &quot;</span></div>
<div class="line">SENDA 56</div>
<div class="line">LDAI 123456781234FE77</div>
<div class="line">CMPA_BEQ 0 FAIL2</div>
<div class="line">LDAI 5041535300000000 <span class="comment">// &quot;PASS&quot;</span></div>
<div class="line">BRA PASS2</div>
<div class="line">FAIL2:</div>
<div class="line">LDAI 2A4641494C2A0000 <span class="comment">// &quot;*FAIL*&quot;</span></div>
<div class="line">PASS2:</div>
<div class="line">SENDA 64           <span class="comment">// Put PASS/FAIL in Comm Buffer</span></div>
<div class="line">EOM 128            <span class="comment">// Return Results</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md109"></a>
Loading VSS keys in X9SWKB format</h2>
<p><b>Source code for complete solution (VSS scripts + test code) can be found <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse">here</a></b></p>
<h3><a class="anchor" id="autotoc_md110"></a>
Introduction</h3>
<p>This document provides code samples to implement secure key block unwrapping using the X9SWKB format according to ANSI X9.143-2021 Interoperable Secure Key Exchange Key Block Specification for VOS1/VOS2 platforms using VSS macros. The main use case will be unwrapping session keys conveyed in key block form e.g., for PIN, data, or MAC, using a pre-loaded KBPK. It can be also used to load other KBPKs (or update the same), or KEKs. Samples of both TDEA and AES key derivation binding methods are provided. Legacy key variant methods are not provided as they are not allowed by PCI requirements. The code samples for the key unwrapping process include VSS macros and open side code as the processing need to be split between these two processing elements. The code samples are not complete, i.e., that the application developer can use the samples as starting point and need to complete and tailor according to the specific needs.</p>
<h3><a class="anchor" id="autotoc_md111"></a>
Loading KBPK key</h3>
<p>This sample demonstrates KBPK loading in plaintext format. However, there are several ways available to perform KBPK loading:</p><ul>
<li>VRK and VRKv2 key loading</li>
<li>Self-update of the KBPK using X9SWKB</li>
<li>Under VSS_KLK in case if only used as KBPK and for 2TDEA key block binding</li>
<li>Plaintext key injection using customer specific injection protocol</li>
</ul>
<h3><a class="anchor" id="autotoc_md112"></a>
Implementation details</h3>
<p>This sample implementation includes the following steps:</p><ol type="1">
<li>KBPK key loading in plaintext</li>
<li>KBH loading</li>
<li>Loading RCVD_MAC</li>
<li>KBEK and KBAK key derivation</li>
<li>Confidential data decryption with plaintext data returned to user space (optional)</li>
<li>MAC calculation</li>
<li>MAC verification</li>
<li>2TDEA Working Key (Session Key) loading into VSS slots or DUKPT Initial Key loading into VSS slots</li>
<li>Further operations with the loaded keys - Working Key decryption with the Master Key, PIN encryption sample macros for TDEA DUKPT, key loading into AES DUKPT engine for AES DUKPT key</li>
</ol>
<h3><a class="anchor" id="autotoc_md113"></a>
Implementation details</h3>
<ul>
<li>The implementation doesn't include block parsing and verification. This must be done by the developer and can be done in user space</li>
<li>The implementation doesn't include proper key obfuscation padding handling (while it's present in the key data). This can be done in user space</li>
<li>On key block confidential data decryption, instead of returning plaintext data from VSS to user space it's possible to save data in VSS slots directly to not expose the data. The corresponding VSS macros (ALGO_CBC_DECRYPT_ITER and LOAD_SK_KEY_KB) must be adjusted by the developer in this case.</li>
<li>This implementation acquires the plaintext SK by decrypting the loaded WK with MK provided in plaintext. Same as KBPK, MK can also be loaded via VRK, VSS_KLK or custom scheme. As for usage, plaintext key returned to the user space can be used for further injection of the key into AESDUKPT engine. If the unwrapped key stays in the VSS plain it can be used for encryption (PIN, data or MAC) using VSS macros.</li>
<li>This implementation doesn't provide macro for obtaining KBH to user space, but it can be easily achieved via VSS + API call</li>
<li>The script samples are made for following key derivation algorithms:<ul>
<li>2TDEA</li>
<li>3TDEA</li>
<li>AES-128</li>
<li>AES-256</li>
</ul>
</li>
<li>The above implementations can be used as a guide to implement DEA and AES-192</li>
<li>The data storage for keys, KBH, KBPK and MAC use pre-allocated VSS script slots</li>
<li>The script developer must know the sizes of the KBPK, KBH, keys, MAC to be able to designate enough data blocks</li>
<li>All data is processed in 8 byte blocks (VSS slots)</li>
</ul>
<h3><a class="anchor" id="autotoc_md114"></a>
TDEA Key Derivation Binding (ID 'B')</h3>
<p>VSS Script sources: <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse/scripts/vss_x9swkb_2tdea.vss">2TDEA</a> <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse/scripts/vss_x9swkb_3tdea.vss">3TDEA</a></p>
<h4><a class="anchor" id="autotoc_md115"></a>
KBPK loading</h4>
<p>KBPK is loaded in plaintext using the data loading function:</p>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; kbpk_key = { 0xDD, 0x75, 0x15, 0xF2, 0xBF, 0xC1, 0x7F, 0x85,</div>
<div class="line">                          0xCE, 0x48, 0xF3, 0xCA, 0x25, 0xCB, 0x21, 0xF6 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Loading KBPK */</span></div>
<div class="line">ret = loadData(TDEA2_SCRIPT_ID, kbpk_key, KBPK_FIRST_SLOT, kbpk_key.size() / DATABLOCK_SIZE);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md116"></a>
KBH loading</h4>
<p>KBH is loaded into dedicated VSS slots using the data loading function:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> std::string key1_x9swkb = <span class="stringliteral">&quot;B0096P0TE00E0000&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;94B420079CC80BA3461F86FE26EFC4A38C6B0A146BF1B0BE0D3277F17A3AD514&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;6EED7B727B8A248E&quot;</span>;</div>
<div class="line"> </div>
<div class="line">std::string key1_kbh = key1_x9swkb.substr(0, 16);</div>
<div class="line">std::vector&lt;unsigned char&gt; key1_kbh_bytes = hexToBytes(key1_kbh);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Loading KBH */</span></div>
<div class="line">ret = loadData(TDEA2_SCRIPT_ID, key1_kbh_bytes, KBH1_FIRST_SLOT, key1_kbh_bytes.size() / DATABLOCK_SIZE);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md117"></a>
RCVD_MAC loading</h4>
<div class="fragment"><div class="line">std::string key1_mac = key1_x9swkb.substr(80, 16);</div>
<div class="line">std::vector&lt;unsigned char&gt; key1_mac_bytes = hexToBytes(key1_mac);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Loading RCVD_MAC */</span></div>
<div class="line">ret = loadData(TDEA2_SCRIPT_ID, key1_mac_bytes, RCVD_MAC_FIRST_SLOT, key1_mac_bytes.size() / DATABLOCK_SIZE);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md118"></a>
KBEK and KBAK key derivation</h4>
<p>KBEK and KBAK are derived in the VSS via macro. The API call for the derivation doesn't need any input or output data parameters:</p>
<div class="fragment"><div class="line"><span class="comment">/* Derive KBEK and KBAK from KBPK */</span></div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_SCRIPT_ID, TDEA2_DERIVE_KBAK_KBEK, 0, NULL, 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md119"></a>
Confidential data decryption</h4>
<p>This process performs the iterative decryption of the confidential data of the secure key block in CBC mode using the MAC as IV. Before decryption IV is set to MAC value loaded in previous step.</p>
<div class="fragment"><div class="line"><span class="comment">/* Set MAC as IV for decryption */</span></div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_SCRIPT_ID, TDEA_CBC_SET_MAC_AS_IV, 0, NULL, 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Decrypt data iteratively */</span></div>
<div class="line">std::vector&lt;uint8_t&gt; key1_dec_bytes;</div>
<div class="line">ret = decryptData(TDEA2_SCRIPT_ID, TDEA2_CMAC_ITER, TDEA_BLOCK_SIZE, key1_key_bytes, key1_dec_bytes);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md120"></a>
MAC verification</h4>
<p>MAC verification is done in two parts: first is iterative MAC calculation on n - 1 data blocks, then the last block is passed into another macro for MAC finalizing and comparison with RCVD_MAC.</p>
<div class="fragment"><div class="line"><span class="comment">/* Verify MAC iteratively */</span></div>
<div class="line">std::vector&lt;uint8_t&gt; mac_input_bytes;</div>
<div class="line">mac_input_bytes.insert( mac_input_bytes.end(), key1_kbh_bytes.begin(), key1_kbh_bytes.end());</div>
<div class="line">mac_input_bytes.insert( mac_input_bytes.end(), key1_dec_bytes.begin(), key1_dec_bytes.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* For TDEA CMAC IV is used as a temporary buffer */</span></div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_SCRIPT_ID, IV_CLEAR, 0, NULL, 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line">ret = verifyMAC(TDEA2_SCRIPT_ID, TDEA2_CMAC_ITER, TDEA2_CMAC_CMP, TDEA_BLOCK_SIZE, mac_input_bytes);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md121"></a>
2TDEA Working Key (Session Key) loading into VSS slots</h4>
<div class="fragment"><div class="line"><span class="comment">/* Load WK from decrypted confidential part to VSS */</span></div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_SCRIPT_ID, LOAD_SK_KEY_KB, key1_dec_bytes.size(), key1_dec_bytes.data(), 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md122"></a>
Working Key decryption with the plaintext Master Key</h4>
<div class="fragment"><div class="line"><span class="comment">/* Get SK by decrypting WK with MK */</span></div>
<div class="line">std::vector&lt;uint8_t&gt; session_key(2 * TDEA_BLOCK_SIZE);</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> out_size = 0;</div>
<div class="line"> </div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_SCRIPT_ID, TDEA2_ECB_WK_DECRYPT, master_key.size(), master_key.data(), session_key.size(), &amp;out_size, session_key.data());</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md123"></a>
AES Key Derivation Binding (ID 'D')</h3>
<p><a class="anchor" id="aes_deriv"></a> VSS Script sources: <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse/scripts/vss_x9swkb_aes128.vss">AES-128</a> <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse/scripts/vss_x9swkb_aes256.vss">AES-256</a></p>
<h4><a class="anchor" id="autotoc_md124"></a>
KBPK loading</h4>
<p>KBPK is loaded in plaintext using the data loading function:</p>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; kbpk_key = { 0xDD, 0x75, 0x15, 0xF2, 0xBF, 0xC1, 0x7F, 0x85,</div>
<div class="line">                          0xCE, 0x48, 0xF3, 0xCA, 0x25, 0xCB, 0x21, 0xF6 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Loading KBPK */</span></div>
<div class="line">ret = loadData(AES128_SCRIPT_ID, kbpk_key, KBPK_FIRST_SLOT, kbpk_key.size() / DATABLOCK_SIZE);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md125"></a>
KBH loading</h4>
<p>KBH is loaded into dedicated VSS slots using the data loading function:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> std::string key2_x9swkb = <span class="stringliteral">&quot;D0160K0AE00N0200LB0BAES_KEYPB050&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;3F89491AE7D048A64361CB2A500FA35CBA0DD6D1368A0CA4F8D9C8E136A69DFEA19EECFF9F83699257A21066EEA5502E&quot;</span></div>
<div class="line">                                  <span class="stringliteral">&quot;F5BA53A8C756450F5CA47505C17D15D8&quot;</span>;</div>
<div class="line"> </div>
<div class="line">std::string key2_kbh = key2_x9swkb.substr(0, 32);</div>
<div class="line">std::vector&lt;unsigned char&gt; key2_kbh_bytes = hexToBytes(key2_kbh);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Loading KBH */</span></div>
<div class="line">ret = loadData(AES128_SCRIPT_ID, key2_kbh_bytes, KBH2_FIRST_SLOT, key2_kbh_bytes.size() / DATABLOCK_SIZE);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md126"></a>
RCVD_MAC loading</h4>
<div class="fragment"><div class="line">std::string key2_mac = key2_x9swkb.substr(80, 16);</div>
<div class="line">std::vector&lt;unsigned char&gt; key2_mac_bytes = hexToBytes(key2_mac);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Loading RCVD_MAC */</span></div>
<div class="line">ret = loadData(TDEA2_SCRIPT_ID, key2_mac_bytes, RCVD_MAC_FIRST_SLOT, key2_mac_bytes.size() / DATABLOCK_SIZE);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md127"></a>
KBEK and KBAK key derivation</h4>
<p>KBEK and KBAK are derived in the VSS via macro. The API call for the derivation doesn't need any input or output data parameters:</p>
<div class="fragment"><div class="line"><span class="comment">/* Derive KBEK and KBAK from KBPK */</span></div>
<div class="line">ret = iPS_ExecuteScript(AES128_SCRIPT_ID, AES128_DERIVE_KBAK_KBEK, 0, NULL, 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md128"></a>
Confidential data decryption</h4>
<p>This process performs the iterative decryption of the confidential data of the secure key block in CBC mode using the MAC as IV. Before decryption IV is set to MAC value loaded in previous step.</p>
<div class="fragment"><div class="line"><span class="comment">/* Set MAC as IV for decryption */</span></div>
<div class="line">ret = iPS_ExecuteScript(AES128_SCRIPT_ID, AES_CBC_SET_MAC_AS_IV, 0, NULL, 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Decrypt data iteratively */</span></div>
<div class="line">std::vector&lt;uint8_t&gt; key2_dec_bytes;</div>
<div class="line">ret = decryptData(AES128_SCRIPT_ID, AES128_CBC_DECRYPT_ITER, AES_BLOCK_SIZE, key2_key_bytes, key2_dec_bytes);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md129"></a>
MAC verification</h4>
<p>MAC verification is done in two parts: first is iterative MAC calculation on n - 1 data blocks, then the last block is passed into another macro for MAC finalizing and comparison with RCVD_MAC.</p>
<div class="fragment"><div class="line"><span class="comment">/* Verify MAC iteratively */</span></div>
<div class="line">std::vector&lt;uint8_t&gt; mac_input_bytes;</div>
<div class="line">mac_input_bytes.insert( mac_input_bytes.end(), key2_kbh_bytes.begin(), key2_kbh_bytes.end());</div>
<div class="line">mac_input_bytes.insert( mac_input_bytes.end(), key2_dec_bytes.begin(), key2_dec_bytes.end());</div>
<div class="line"> </div>
<div class="line">ret = verifyMAC(AES128_SCRIPT_ID, AES128_CMAC_ITER, AES128_CMAC_CMP, AES_BLOCK_SIZE, mac_input_bytes);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md130"></a>
2TDEA Working Key (Session Key) loading into VSS slots</h4>
<div class="fragment"><div class="line"><span class="comment">/* Load WK from decrypted confidential part to VSS */</span></div>
<div class="line">ret = iPS_ExecuteScript(AES128_SCRIPT_ID, LOAD_SK_KEY_KB, key2_dec_bytes.size(), key2_dec_bytes.data(), 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md131"></a>
Working Key decryption with the plaintext Master Key</h4>
<div class="fragment"><div class="line"><span class="comment">/* Get SK by decrypting WK with MK */</span></div>
<div class="line">std::vector&lt;uint8_t&gt; session_key(2 * TDEA_BLOCK_SIZE);</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> out_size = 0;</div>
<div class="line"> </div>
<div class="line">ret = iPS_ExecuteScript(AES128_SCRIPT_ID, TDEA2_ECB_WK_DECRYPT, master_key.size(), master_key.data(), session_key.size(), &amp;out_size, session_key.data());</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md132"></a>
TDEA DUKPT key loading</h3>
<p>VSS Script source: <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse/scripts/vss_x9swkb_dukpt_2tdea.vss">2TDEA DUKPT</a></p>
<h4><a class="anchor" id="autotoc_md133"></a>
Key unwrapping</h4>
<p>In this example, AES-128 Key Derivation Binding is used, so the key is unwrapped in the way described in the <a href="#aes_deriv">AES Key Derivation Binding</a> section. KSN must be parced from KBH.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> std::string tdea2_dukpt_x9swkb = <span class="stringliteral">&quot;D0192B1TX00N0500KS1800604B120F9292800000KP1001D77F007724KC0C0057C409TS1320241008034229ZPB0900000&quot;</span></div>
<div class="line">                                                                    <span class="stringliteral">&quot;7FD21FD44DBD73E8D50C7E7B7BC6D943BCA428E15607D128491D633B9E6323CF&quot;</span></div>
<div class="line">                                                                    <span class="stringliteral">&quot;FFA45C04269AC320969D21731B9978FD&quot;</span></div>
<div class="line"> </div>
<div class="line">std::string tdea2_kbh = tdea2_x9swkb.substr(0, 96);</div>
<div class="line">std::string ksn = tdea2_kbh.substr(20, 20);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;unsigned char&gt; ksn_bytes = hexToBytes(ksn);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md134"></a>
KSN and key loading into VSS</h4>
<p>To load KSN, it should be passed into VSS via the VSS API from dedicated KBH field. Key loading is performed by passing the decrypted confidential data to VSS macro.</p>
<div class="fragment"><div class="line"><span class="comment">/* Load IK from decrypted confidential part to VSS */</span></div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_DUKPT_SCRIPT_ID, LOAD_IK_KEY_KB, tdea2_dec_bytes.size(), tdea2_dec_bytes.data(), 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Load KSN */</span></div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_DUKPT_SCRIPT_ID, TDEA2_DUKPT_LOAD_KSN, ksn_bytes.size(), ksn_bytes.data(), 0, NULL, NULL);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md135"></a>
Next Key generation</h4>
<p>Next Key and KSN are generated by one call, KSN is returned by the API. It should be saved for next generation iteration.</p>
<div class="fragment"><div class="line"><span class="comment">/* Generate next key */</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> returned_ksn[KSN_LENGTH] = {0};</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> outlen;</div>
<div class="line">ret = iPS_ExecuteScript(TDEA2_DUKPT_SCRIPT_ID, TDEA2_DUKPT_GEN_KEYS, 0, NULL, KSN_LENGTH, &amp;outlen, ksn);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line">CHECK_EQUAL(KSN_LENGTH, outlen);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md136"></a>
MAC calculation</h4>
<p>For MAC calculation, common functions can be used with corresponding scripts.</p>
<div class="fragment"><div class="line">std::string msg = <span class="stringliteral">&quot;0123456789ABCDEFFEDCBA9876543210&quot;</span>;</div>
<div class="line">std::vector&lt;unsigned char&gt; msg_bytes = hexToBytes(msg);</div>
<div class="line">std::vector&lt;uint8_t&gt; msg_input_bytes;</div>
<div class="line">msg_input_bytes.insert( msg_input_bytes.end(), msg_bytes.begin(), msg_bytes.end());</div>
<div class="line"> </div>
<div class="line">ret = verifyMAC(TDEA2_DUKPT_SCRIPT_ID, TDEA2_DUKPT_MAC_TDEA_REQUEST, TDEA2_DUKPT_MAC_3TDEA_REQUEST, TDEA_BLOCK_SIZE, msg_input_bytes);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
</div><!-- fragment --><p>Data and PIN encryption Data encryption should be performed iteratively, in the same manner as MAC calculation. See 2TDEA_DUKPT_ENCRYPT_DATA_REQ and 2TDEA_DUKPT_ENCRYPT_DATA_RESP macros. PIN encryption has a dedicated macro for that</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[KEY_SLOT_SIZE + KSN_LENGTH];</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> epb[MAX_PIN_LENGTH], pin[MAX_PIN_LENGTH];</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> outlen = 0;</div>
<div class="line"><span class="comment">/* Arguments for PIN entry on VATS device */</span></div>
<div class="line"><span class="keywordtype">int</span> iStatus = PIN_IDLE;</div>
<div class="line"><span class="keywordtype">char</span> enter_key[1] = {VATS_KEY_ENTER};</div>
<div class="line">PINPARAMETER pinparam;</div>
<div class="line">PINRESULT <a class="code" href="namespacevficom_1_1cmdparam_1_1in_1_1stk__write_1_1msg_1_1tr_1_1refresh.html#a625b9748e49ec8ee41ab3546a32415c0">result</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Perform PIN entry on VATS device */</span></div>
<div class="line">memset(&amp;pinparam, 0, <span class="keyword">sizeof</span>(pinparam));</div>
<div class="line"><span class="comment">/* Set the values of PINPARAMETER vector */</span></div>
<div class="line">pinparam.ucMin = 4;</div>
<div class="line">pinparam.ucMax = 8;</div>
<div class="line">pinparam.ucEchoChar = <span class="charliteral">&#39;*&#39;</span>;</div>
<div class="line">pinparam.ucDefChar = 0;</div>
<div class="line">pinparam.ucOption = 0;</div>
<div class="line"> </div>
<div class="line">ret = iPS_SelectPINAlgo(VSS_PIN);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!ret)</div>
<div class="line">{</div>
<div class="line">    iPS_CancelPIN();</div>
<div class="line">    ret = iPS_SetPINParameter(&amp;pinparam);</div>
<div class="line"> </div>
<div class="line">    VFLOG_INFO(<span class="stringliteral">&quot;%s: Request PIN entry\n&quot;</span>, __func__);</div>
<div class="line">    <span class="keywordflow">if</span> (!ret)</div>
<div class="line">    {</div>
<div class="line">        ret = iPS_RequestPINEntry(0, NULL);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!ret)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (int)strlen(test_pin); i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Adding artificial delay of 250ms to allow process key, and imitating real pin entry.*/</span></div>
<div class="line">        usleep(250000);</div>
<div class="line">        VATS_InjectKeys(&amp;test_pin[i], 1);</div>
<div class="line">        VFLOG_INFO(<span class="stringliteral">&quot;PIN Digit Entered: %c \n&quot;</span>, test_pin[i]);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Delay before pin &quot;enter&quot; key. */</span></div>
<div class="line">    usleep(250000);</div>
<div class="line">    VATS_InjectKeys(enter_key, 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(iStatus != PIN_DONE) ret = iPS_GetPINResponse(&amp;iStatus, &amp;<a class="code" href="namespacevficom_1_1cmdparam_1_1in_1_1stk__write_1_1msg_1_1tr_1_1refresh.html#a625b9748e49ec8ee41ab3546a32415c0">result</a>);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    VFLOG_INFO(<span class="stringliteral">&quot;%s: PIN Entered successfully!\n&quot;</span>, __func__);</div>
<div class="line"> </div>
<div class="line">    memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line">    outlen = (strlen(pan) - 1) / 2 + (strlen(pan) - 1) % 2;</div>
<div class="line"> </div>
<div class="line">    SVC_DSP_2_HEX (pan, &amp;buffer[DATA_BLOCK_SIZE - outlen], outlen);</div>
<div class="line">    outlen = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * PIN Encryption (ANS X9.8).</span></div>
<div class="line"><span class="comment">     * When PIN entry is complete, put 8 bytes of account data in epb.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    ret = iPS_ExecuteScript(TDEA2_DUKPT_SCRIPT_ID, 2TDEA_DUKPT_ENCRYPT_PIN, <span class="keyword">sizeof</span>(pan), buffer,</div>
<div class="line">                                MAX_PIN_LENGTH, &amp;outlen, epb);</div>
<div class="line">    CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* if EPB returned correctly, check if it can be decrypted with dukInitKey &amp; current KSN */</span></div>
<div class="line">    <span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        CHECK_EQUAL(MAX_PIN_LENGTH, outlen);</div>
<div class="line">        VFLOG_INFO(<span class="stringliteral">&quot;%s: EPB verified okay!\n&quot;</span>, __func__);</div>
<div class="line">        print_hex(<span class="stringliteral">&quot;EPB&quot;</span>, epb, outlen);</div>
<div class="line"> </div>
<div class="line">        memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"> </div>
<div class="line">        ret = duk_decrypt_pin(epb, ksn, pin);</div>
<div class="line">        CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">            VFLOG_INFO(<span class="stringliteral">&quot;%s: EPB decrypted successfully!\n&quot;</span>, __func__);</div>
<div class="line"> </div>
<div class="line">            CHECK_EQUAL(0, memcmp(test_pin, pin, strlen(test_pin)));</div>
<div class="line">            VFLOG_INFO(<span class="stringliteral">&quot;%s: Decrypted PIN verified successfully!\n&quot;</span>, __func__);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            VFLOG_INFO(<span class="stringliteral">&quot;%s: EPB decryption failed!\n&quot;</span>, __func__);</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        VFLOG_INFO(<span class="stringliteral">&quot;%s: EPB verification failed!\n&quot;</span>, __func__);</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    VFLOG_INFO(<span class="stringliteral">&quot;%s: PIN entry failed!\n&quot;</span>, __func__);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md137"></a>
AES DUKPT key loading</h3>
<p>VSS Script source: <a href="https://bitbucket.verifone.com:8443/projects/ADVTOOLS/repos/poc-vss-x9swkb/browse/scripts/vss_x9swkb_aes128_dukpt.vss">AES-128 DUKPT</a></p>
<h4><a class="anchor" id="autotoc_md138"></a>
Key unwrapping</h4>
<p>In this example, AES-128 Key Derivation Binding is used, so the key is unwrapped in the way described in the <a href="#aes_deriv">AES Key Derivation Binding</a> section</p>
<h4><a class="anchor" id="autotoc_md139"></a>
Key loading into VSS</h4>
<p>VSS does not support AES DUKPT. Therefore, the key can be unwrapped but further operations are impossible. After unwrapping, key loading is performed by passing the decrypted confidential data to VSS macro. The VSS macro returns the key to user side so it can be passed into AES DUKPT engine.</p>
<div class="fragment"><div class="line"><span class="comment">/* Load IK from decrypted confidential part to VSS */</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> returned_initial_key[AES_BLOCK_SIZE] = {0};</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> outlen;</div>
<div class="line">ret = iPS_ExecuteScript(AES128_DUKPT_SCRIPT_ID, LOAD_IK_KEY_KB, aes128_dec_bytes.size(), aes128_dec_bytes.data(), AES_BLOCK_SIZE, &amp;outlen, returned_initial_key);</div>
<div class="line">CHECK_EQUAL(0, ret);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Load initial key into vfiSec AES DUKPT engine */</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags = 0; <span class="comment">// Define your flags here</span></div>
<div class="line">err = vfiSec_load_aesdukpt_initial_key(returned_initial_key, AES_BLOCK_SIZE, iksn.data(), 1, <span class="stringliteral">&quot;Test_AES_DUKPT&quot;</span>, aes128_kbh.data(), aes128_kbh.size(), flags);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md140"></a>
Common functions</h3>
<p>This is a common function that allows loading data iteratively into VSS slots. Each VSS API call consists of 1 byte of slot index and 8 bytes of data. This can be used for plaintext KBPK, KBH and received MAC loading.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> loadData(<span class="keywordtype">int</span> scriptId, std::vector&lt;uint8_t&gt; &amp; data, <span class="keywordtype">int</span> firstSlot, <span class="keywordtype">int</span> blockCount)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;uint8_t&gt;::iterator it = data.begin();</div>
<div class="line">  <span class="keywordtype">int</span> ret = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; blockCount; i++)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;uint8_t&gt; block(DATABLOCK_SIZE);</div>
<div class="line">    block.assign(it, it + DATABLOCK_SIZE);</div>
<div class="line">    block.insert(block.begin(), firstSlot + i);</div>
<div class="line">    ret = iPS_ExecuteScript(scriptId, LOAD_DATA_ITERATION, block.size(), block.data(), 0, NULL, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (ret) <span class="keywordflow">break</span>;</div>
<div class="line">    it += DATABLOCK_SIZE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is a common function that performs data decryption iteratively. The data block size depends on the algorithm. Before data decryption, macro that sets MAC as IV should be called.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> decryptData(<span class="keywordtype">int</span> scriptId, <span class="keywordtype">int</span> macroId, <span class="keywordtype">int</span> blockSize, std::vector&lt;uint8_t&gt; &amp; data, std::vector&lt;uint8_t&gt; &amp; outData)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;uint8_t&gt;::iterator it = data.begin();</div>
<div class="line">  <span class="keywordtype">int</span> ret = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; data.size() / blockSize; i++)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;uint8_t&gt; enc_block(blockSize);</div>
<div class="line">    std::vector&lt;uint8_t&gt; dec_block(blockSize);</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> out_size = 0;</div>
<div class="line"> </div>
<div class="line">    enc_block.assign(it, it + blockSize);</div>
<div class="line">    ret = iPS_ExecuteScript(scriptId, macroId, blockSize, enc_block.data(), blockSize, &amp;out_size, dec_block.data());</div>
<div class="line">    <span class="keywordflow">if</span> (ret != 0 || out_size != blockSize) <span class="keywordflow">break</span>;</div>
<div class="line">    outData.insert( outData.end(), dec_block.begin(), dec_block.end());</div>
<div class="line">    it += blockSize;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function is used for MAC calculation verification iteratively and verifies MAC on the last step. The data block size depends on the algorithm. Both calculation and verification macro IDs must be provided.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> verifyMAC(<span class="keywordtype">int</span> scriptId, <span class="keywordtype">int</span> iterMacroId, <span class="keywordtype">int</span> cmpMacroId, <span class="keywordtype">int</span> blockSize, std::vector&lt;uint8_t&gt; &amp; data)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> ret = 0;</div>
<div class="line">  std::vector&lt;uint8_t&gt;::iterator it = data.begin();</div>
<div class="line">  std::vector&lt;uint8_t&gt; block(blockSize);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (data.size() / blockSize) - 1; i++)</div>
<div class="line">  {</div>
<div class="line">    block.assign(it, it + blockSize);</div>
<div class="line">    ret = iPS_ExecuteScript(scriptId, iterMacroId, blockSize, block.data(), 0, NULL, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (ret) <span class="keywordflow">break</span>;</div>
<div class="line">    it += blockSize;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (ret != 0) ret = iPS_ExecuteScript(scriptId, cmpMacroId, blockSize, block.data(), 0, NULL, NULL);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md141"></a>
Script with several keys</h3>
<p>Since key and data storage is hardcoded, one script can contain several keys encrypted with the same KBPK, stored in the predefined slots, i.e:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key type </th><th class="markdownTableHeadNone">Slots </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">KBPK </td><td class="markdownTableBodyNone">0 - 3 </td><td class="markdownTableBodyNone">From 8 (TDEA) to 32 (AES256) bytes max  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">KEY1 KBH </td><td class="markdownTableBodyNone">4 - 15 </td><td class="markdownTableBodyNone">96 bytes max for KBHs with opt blocks  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">KEY1 </td><td class="markdownTableBodyNone">16 - 23 </td><td class="markdownTableBodyNone">From 8 (TDEA) to 64 (HMAC) bytes max  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">KEY2 KBH </td><td class="markdownTableBodyNone">24 - 35 </td><td class="markdownTableBodyNone">96 bytes max for KBHs with opt blocks  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">KEY2 </td><td class="markdownTableBodyNone">36 - 43 </td><td class="markdownTableBodyNone">From 8 (TDEA) to 64 (HMAC) bytes max  </td></tr>
</table>
<h1><a class="anchor" id="sec_vss_macro_command_execution"></a>
Macro Command Execution</h1>
<h2><a class="anchor" id="subsec_vss_security_script_file_download"></a>
Security Script File Download</h2>
<p>The file generated by the script-processing tool has a .VSO extension that is recognized by the unit as a VeriShield Security Script file. The .VSO file must be downloaded along with its signature file (P7S) into the unit using the Zontalk protocol. Script files must be signed using signer certificates that have specific “xV” attributes authorizing them to sign scripts. For instance, to load a script in group 13, the file must be signed with a certificate that has the “13V” attribute. Else the authentication will fail.</p>
<p>There is a slight difference between the SC 5000 PINpads and Vx terminals regarding the downloads and install process.</p>
<h3><a class="anchor" id="subsubsec_vss_in_the_sc_5000_pinpads"></a>
In the SC 5000 PINpads</h3>
<p>Upon successful authentication by the VeriShield File Authentication module, the script file is automatically installed in the PINpad. It is checked for validity and consistency. If everything is coherent, then the macro commands are stored in the security module and the space for the keys defined in the script are allocated. The script file is then deleted from the file system irrespective of the loading, whether successful or not. Three API functions are available to access the VeriShield Security Scripts from a SC 5000 application:</p>
<p><code> iPS_GetScriptStatus()<br  />
 iPS_ExecuteScript()<br  />
 iPS_DeleteScript()<br  />
 </code></p>
<dl class="section note"><dt>Note</dt><dd>Please refer to VDN22425 - SC 5000 API for description of those functions.</dd></dl>
<h3><a class="anchor" id="subsubsec_vss_in_the_vx_terminals"></a>
In the Vx Terminals</h3>
<p>Upon successful authentication by the VeriShield File Authentication module, the script file is not automatically installed in the PINpad. The terminal application must install the script using the <code>iPS_InstallScript()</code> function. During the install process the file is checked for validity and consistency. If everything is coherent, then the script is validated and the space for the keys defined in the script are allocated. The script file is not deleted from the file system and should not be deleted or replaced because it would invalidate the script. This difference with the SC 5000 is partly because Vx terminals should support back-to-back downloads.</p>
<p>Four API functions are available to access the VeriShield Security Scripts from a Vx application:</p>
<p><code>iPS_InstallScript()</code> – This function installs a script file in the unit.<br  />
 <code>iPS_GetScriptStatus()</code><br  />
 <code>iPS_ExecuteScript()</code><br  />
 <code>iPS_UninstallScript()</code> – This function uninstalls the script but does not delete the script file.</p>
<h3><a class="anchor" id="subsubsec_vss_pin_sessions"></a>
PIN Sessions</h3>
<p>In order to perform a PIN session using a macro command, the <code>iPS_SelectPINAlgo()</code> API function has to be called with the PinFormat parameter equal to 0Bh. In such a case, once the PIN entry is completed, the PIN is stored into a specific buffer inside the security module. The PIN is then retrieve by the “PIN processing“ macro using the GETPINx commands. The PIN is not be accessible at the application level. From the PINpad application the sequence looks like the following:</p>
<ul>
<li>Setup parameters for the upcoming PIN session: <code>iPS_PINParameters(…);</code></li>
<li>Select PIN algorithm with parameter 0Bh (Store PIN internally for postprocessing by a VeriShield Security Script macro command: <code>iPS_SelectPINAlgo(0x0B);</code></li>
<li>Request PIN Entry: <code>iPS_RequestPINEntry(0, 0);</code></li>
<li>do {Get PIN Response: <code>iPS_GetPINResponse(…);</code> } while (not done)</li>
<li>Execute the custom “PIN processing” macro <code>iPS_ExecuteScript(Script#, Macro#, …);</code></li>
</ul>
<h3><a class="anchor" id="subsubsec_vss_security_script_library"></a>
Security Script Library</h3>
<p>A terminal library could be developed along with each VeriShield Security Script. If this library has the same API as the related SCxxx library, it would ease the application conversion when switching from an SCxxx to another device.</p>
<h1><a class="anchor" id="sec_vss_tools"></a>
Tools</h1>
<h2><a class="anchor" id="subsec_vss_script_processor"></a>
Script Processor (VSS Compiler)</h2>
<p>The script processor tool takes ASCII script file as an input and generates a binary file to be downloaded into the unit. It also generates a report file (.LOG) containing the results of the last execution. If errors are found, then they are listed in the report file for debugging purposes. If the execution is successful, then some information is reported (number of macros and blocks, code size,…).</p>
<p>The engineering version of the VeriShield Security Script Processor Tool is a Win32 console application. The name of the executable is VSSCONV.EXE. The name of the input ASCII file must be passed as parameter.</p>
<p>/verbatim C:&gt;VSSCONV libtest VeriShield Security Script Tool version 9.0 - PSVSSv90 - 20200204 Copyright (c) 2001-2020, Verifone, Inc. libtest - 0 error(s). Execution ended normally. /endverbatim</p>
<p>After the execution, a report file (.LOG) is generated.</p>
<p>/verbatim VeriShield Security Script Tool version 9.0 - PSVSSv90 - 20200204 Copyright (c) 2001-2020, Verifone, Inc.</p>
<p>libtest - 0 error(s).</p>
<p>Tool Identifier (Max Op Code Version Used): PSVSSv2 Tool Version: 9.0 Script Identifier: 00 hex (00 decimal) Script Name: Tst0v2op PP1000 compatible commands are disabled. Default Master/Session functions are disabled. Default DUKPT functions are disabled. Number of Macros: 2 (2h) Macro Code Size: 237 (EDh) bytes Total number of blocks: 40 (28h) of which 0 (0h) can be loaded using the default key loading functions. Number of pre-loaded blocks: 1 (1h)</p>
<p>Execution ended normally. /endverbatim</p>
<dl class="section note"><dt>Note</dt><dd>Before using/loading scripts on ADK upgrade, make sure the appropriate VSSConv verson is used and scripts are re-compiled. Ignoring that requirement may lead to unexpected failures on different stages of loading/processing scripts.</dd></dl>
<p>Below is a table of VSSConv/ADK and feature mapping:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">VSSConv version </th><th class="markdownTableHeadNone">ADK version </th><th class="markdownTableHeadNone">Number of 'usr' scripts supported </th><th class="markdownTableHeadNone">Number of 'sys' scripts supported </th><th class="markdownTableHeadNone">RSA-4096  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VSSConv 6.0, VSSConv7.0 </td><td class="markdownTableBodyNone">ADK 4.4, ADK 4.6 </td><td class="markdownTableBodyNone">64 </td><td class="markdownTableBodyNone">Not supported </td><td class="markdownTableBodyNone">Not supported  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">VSSConv 8.0 </td><td class="markdownTableBodyNone">ADK 4.7 </td><td class="markdownTableBodyNone">96 </td><td class="markdownTableBodyNone">Not supported </td><td class="markdownTableBodyNone">Not supported  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VSSConv 9.0 </td><td class="markdownTableBodyNone">ADK 4.8 </td><td class="markdownTableBodyNone">96 </td><td class="markdownTableBodyNone">96 </td><td class="markdownTableBodyNone">Not supported  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">VSSConv 9.1 </td><td class="markdownTableBodyNone">ADK 4.8 </td><td class="markdownTableBodyNone">96 </td><td class="markdownTableBodyNone">96 </td><td class="markdownTableBodyNone">Supported  </td></tr>
</table>
<h2><a class="anchor" id="subsec_vss_signing_tool"></a>
Signing Tool</h2>
<p>"VeriShield File Signing Tool" will be used to sign the VeriShield Security Script Object file (.VSO) like every other file to be downloaded into the unit.</p>
<p>The only difference is that the Security Script Object files (.VSO) must be signed with certificates that have script signing capabilities. Because of the sensitive nature of the security script files compared to applications, it is required to have distinct certificate attributes for script signing capability and for application/data signing capability.</p>
<p>This way it is possible to generate smart cards that have only application signing capability for instance.</p>
<p>Like we have attributes "1","2",''3",''4",''5",''6",''7",''9",''10",''11",''12",''13",''14",''15" for applications, we have specific attributes for security scripts.</p>
<p>In the SC5000 the script signing attributes for the 15 groups are:</p>
<p>"1V","2V",''3V",''4V",''5V",''6V",''7V",''9V",''10V",''11V",''12V",''13V",''14V",''15V"</p>
<p>In the Vx terminal the script signing attributes for the 15 groups are:</p>
<p>"A",''B",''C",''D",''E",''F",''G",''H",''I",''J",''K",''L",''M",''N",''O"</p>
<p>For instance, to load a script in group 13, the file must be signed with a certificate that has the “13V” attribute (for SC 5000) or the “M” attribute (for Vx terminals). If not, even though the signing process seems to work, the authentication in the unit will fail.</p>
<h3><a class="anchor" id="subsubsec_vss_signing_tool_in_the_sc_5000_pinpad"></a>
In The SC 5000 PINpad</h3>
<p>The VeriShield Security Script Object files (.VSO) must be downloaded into the SC 5000 PINpads as code files (option.-e with DDL.EXE or option -i with DL.EXE). example: /verbatim ddl.exe -eLibTest.vso LibTest.vso.p7s /endverbatim</p>
<h2><a class="anchor" id="subsec_vss_key_loading_tool"></a>
Key Loading Tool</h2>
<p>SecureKIT is the Key Loading solution of Verifone.</p>
<p>The current version 2.1 of SecureKIT supports a limited set of existing Verifone devices and in most of the cases it cannot be used to load keys defined by a VeriShield Security Script.</p>
<p>The next version of SecureKIT should provide a generic interface for key loading. Being programmable devices, SC 5000 and Vx terminals will easily adapt to it at the application level. The application might be different for each customization, (i.e. for each VeriShield Security Script) in order to interface SecureKIT communication packet into customer-specific key loading macro defined in their script.</p>
<h1><a class="anchor" id="sec_vss_loading_apis"></a>
VSS Key Installation APIs</h1>
<p>There are APIs available that allow loading VSS keys encrypted with: </p><ul>
<li>AuthEx key </li>
<li>Custom Asymmetric Key loaded on the device via VRKv2</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Both of these APIs are vulnerable to the Padding Oracle attack. Use at your own risk.</dd></dl>
<p>In both cases, the encryption keys must be installed on the device.</p>
<h2><a class="anchor" id="sec_vss_loading_authex"></a>
VSS key encrypted with AuthEx</h2>
<p>To load the VSS key encrypted with AuthEx key, the following API is available: </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> rsaAuthexVssKeyInstall(<span class="keywordtype">int</span> encryption_format, <span class="keywordtype">int</span> data_length,</div>
<div class="line">                           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *encrypted_key, <span class="keywordtype">int</span> key_size,</div>
<div class="line">                           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vss_script_num, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vss_key_slot);</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_vss_loading_custom_asymm"></a>
VSS key encrypted with Custom Asymmetric key</h2>
<p>To load the VSS key encrypted with Custom Asymmetric key, the following API is available: </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> customAsymmKeyVssKeyInstall(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *encrypted_key, <span class="keywordtype">int</span> key_size,</div>
<div class="line">                           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vss_script_num, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vss_key_slot, <span class="keyword">const</span> <span class="keywordtype">char</span> * custom_key_filen);</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_vss_appendix_a"></a>
Appendix A: OP Code Table</h1>
<p>The table below indicates the OP Code value for all the keywords that might generate an execution error. This is the value returned by the <code>iPS_ExecuteScript()</code> function when the OP code execution fails.</p>
<a class="anchor" id="multi_row_a1"></a>
<table class="doxtable">
<caption style="text-align:left">Table 1 OP Code Table</caption>
<tr>
<th>OP Code </th><th>Dec </th><th>Hex </th></tr>
<tr>
<td>EOM </td><td>3 </td><td>03 </td></tr>
<tr>
<td>GETA </td><td>4 </td><td>04 </td></tr>
<tr>
<td>SENDA </td><td>5 </td><td>05 </td></tr>
<tr>
<td>GETX </td><td>6 </td><td>06 </td></tr>
<tr>
<td>SENDX </td><td>7 </td><td>07 </td></tr>
<tr>
<td>GETW </td><td>8 </td><td>08 </td></tr>
<tr>
<td>SENDW </td><td>9 </td><td>09 </td></tr>
<tr>
<td>TSTXI </td><td>15 </td><td>0F </td></tr>
<tr>
<td>LSLA </td><td>28 </td><td>1C </td></tr>
<tr>
<td>LSRA </td><td>29 </td><td>1D </td></tr>
<tr>
<td>CMPA_B0 </td><td>40 </td><td>28 </td></tr>
<tr>
<td>CMPA_B1 </td><td>41 </td><td>29 </td></tr>
<tr>
<td>CMPA </td><td>42 </td><td>2A </td></tr>
<tr>
<td>CMPAX </td><td>43 </td><td>2B </td></tr>
<tr>
<td>SELECT </td><td>45 </td><td>2D </td></tr>
<tr>
<td>SELECTX </td><td>47 </td><td>2F </td></tr>
<tr>
<td>DELETE </td><td>48 </td><td>30 </td></tr>
<tr>
<td>DELETEX </td><td>49 </td><td>31 </td></tr>
<tr>
<td>STA </td><td>50 </td><td>32 </td></tr>
<tr>
<td>STAX </td><td>51 </td><td>33 </td></tr>
<tr>
<td>LDA </td><td>52 </td><td>34 </td></tr>
<tr>
<td>LDAX </td><td>53 </td><td>35 </td></tr>
<tr>
<td>CHK_ODD </td><td>56 </td><td>38 </td></tr>
<tr>
<td>CHK_EVEN </td><td>57 </td><td>39 </td></tr>
<tr>
<td>GETPINNB </td><td>68 </td><td>44 </td></tr>
<tr>
<td>GETPIN0 </td><td>69 </td><td>45 </td></tr>
<tr>
<td>GETPIN1 </td><td>70 </td><td>46 </td></tr>
<tr>
<td>GETPIN2 </td><td>71 </td><td>47 </td></tr>
<tr>
<td>GETPIN3 </td><td>72 </td><td>48 </td></tr>
<tr>
<td>SELRSA </td><td>79 </td><td>4F </td></tr>
<tr>
<td>SELRSAX </td><td>80 </td><td>50 </td></tr>
<tr>
<td>STRSA </td><td>81 </td><td>51 </td></tr>
<tr>
<td>STRSAX </td><td>82 </td><td>52 </td></tr>
<tr>
<td>RSACOMP </td><td>83 </td><td>53 </td></tr>
<tr>
<td>SHAUPDATE </td><td>85 </td><td>55 </td></tr>
<tr>
<td>CMPSHA </td><td>88 </td><td>58 </td></tr>
<tr>
<td>GETA_HA_TO_BIN </td><td>89 </td><td>59 </td></tr>
<tr>
<td>GETX_HA_TO_BIN </td><td>90 </td><td>5A </td></tr>
<tr>
<td>SENDA_BIN_TO_HA </td><td>91 </td><td>5B </td></tr>
<tr>
<td>SENDX_BIN_TO_HA </td><td>92 </td><td>5C </td></tr>
<tr>
<td>CMPA_BEQ </td><td>108 </td><td>6C </td></tr>
<tr>
<td>CMPAX_BEQ </td><td>109 </td><td>6D </td></tr>
<tr>
<td>CMPA_BNE </td><td>110 </td><td>6E </td></tr>
<tr>
<td>CMPAX_BNE </td><td>111 </td><td>6F </td></tr>
<tr>
<td>CMPA_BGT </td><td>112 </td><td>70 </td></tr>
<tr>
<td>CMPAX_BGT </td><td>113 </td><td>71 </td></tr>
<tr>
<td>CMPA_BLT </td><td>114 </td><td>72 </td></tr>
<tr>
<td>CMPAX_BLT </td><td>115 </td><td>73 </td></tr>
<tr>
<td>CMPA_BGE </td><td>116 </td><td>74 </td></tr>
<tr>
<td>CMPAX_BGE </td><td>117 </td><td>75 </td></tr>
<tr>
<td>CMPA_BLE </td><td>118 </td><td>76 </td></tr>
<tr>
<td>CMPAX_BLE </td><td>119 </td><td>77 </td></tr>
<tr>
<td>GETW_HA_TO_BIN </td><td>120 </td><td>78 </td></tr>
<tr>
<td>SENDW_BIN_TO_HA </td><td>121 </td><td>79 </td></tr>
<tr>
<td>ERR_RET </td><td>125 </td><td>7D </td></tr>
<tr>
<td>INIT_1DES_DUKPT </td><td>127 </td><td>7F </td></tr>
<tr>
<td>INIT_3DES_DUKPT </td><td>128 </td><td>80 </td></tr>
<tr>
<td>GET_DUKPT_KEY </td><td>129 </td><td>81 </td></tr>
<tr>
<td>DELETE_DUKPT_KEY </td><td>130 </td><td>82 </td></tr>
<tr>
<td>SHA256UPDATE </td><td>132 </td><td>84 </td></tr>
<tr>
<td>CMPSHA256 </td><td>135 </td><td>87 </td></tr>
<tr>
<td>MAC_CB </td><td>151 </td><td>97 </td></tr>
<tr>
<td>MAC_CB_X </td><td>152 </td><td>98 </td></tr>
<tr>
<td>EECB_CB </td><td>153 </td><td>99 </td></tr>
<tr>
<td>EECB_CB_X </td><td>154 </td><td>9A </td></tr>
<tr>
<td>DECB_CB </td><td>155 </td><td>9B </td></tr>
<tr>
<td>DECB_CB_X </td><td>156 </td><td>9C </td></tr>
<tr>
<td>ECBC_CB </td><td>157 </td><td>9D </td></tr>
<tr>
<td>ECBC_CB_X </td><td>158 </td><td>9E </td></tr>
<tr>
<td>DCBC_CB </td><td>159 </td><td>9F </td></tr>
<tr>
<td>DCBC_CB_X </td><td>160 </td><td>A0 </td></tr>
<tr>
<td>OAEP </td><td>161 </td><td>A1 </td></tr>
</table>
<h1><a class="anchor" id="sec_vss_appendix_b"></a>
Appendix B: VSS Troubleshooting Guide</h1>
<p>This chapter describes some common problems that occur with VSS and what are the possible reasons/solutions.</p>
<h2><a class="anchor" id="VSS_load_troubleshooting"></a>
VSS script fails to load</h2>
<p>There are several reasons why VSS script may fail on installation/loading. The reason now can be found in system logs since logging has been added with ADK 4.8. However, since proper logging is absent in earlier versions, here is a list of possible reasons for failure:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Reason </th><th class="markdownTableHeadNone">Solution/description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VSS script ID is incorrect </td><td class="markdownTableBodyNone">With VSS v9.0, the maximum VSS script ID is 191 in decimal value. On VSS version 5.0 and higher, maximal script ID is 63 and on VSS version 8.0 and higher maximal script ID is 95.<br  />
<dl class="section note"><dt>Note</dt><dd>With ADK 4.8, user limitations are added for VSS script ID values. The slots 0 - 95 are now reserved for 'usr' users and slots 96 - 191 are reserved for 'sys' users. The script with incorrect ID range will fail to install with permission error.  </dd></dl>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Inorrect password is defined in script </td><td class="markdownTableBodyNone">In some cases, i.e. when using block retention, a 'password' (RETAIN_BLK code) must be provided in the script. Make sure that password is correct. The valid password can also be the currently loaded script name. If you are loading the script with the same script ID but use different name, password should still be defined as the old (previous) script name.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">System key (KLK) is not loaded </td><td class="markdownTableBodyNone">To perform some initial operations, Key Loading Key aka System key must be present. The KLK can be loaded via <em>iPS_LoadSysClearKey()</em> or <em>iPS_LoadSysEncKey()</em> APIs. Make sure it is present in either clear text or encrypted format.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Incorrect VSSConv version is used </td><td class="markdownTableBodyNone">On different ADK/OS releases different amount of VSS script slots is available. If you switch to newer ADK, <b>make sure you use the corresponding VSSConv version that is distributed with it and re-compile the scripts</b> before loading.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Downgrade to version that does not support script IDs performed </td><td class="markdownTableBodyNone">On downgrade to older ADK versions there is possibility that certain script IDs are not supported. There is no way to downgrade and keep scripts with newer IDs on the device. Max script ID value is 63 decimal for all ADK versions older than 4.7, 95 for ADK 4.7 and 191 for ADK 4.8. Any downgrades between these versions may cause script loading problems.  </td></tr>
</table>
<h2><a class="anchor" id="VSS_keys_troubleshooting"></a>
VSS keys are wiped after the installation</h2>
<p>There are two typical cases when the VSS keys are being wiped after the new VSS script is installed:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Reason </th><th class="markdownTableHeadNone">Solution/description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RETAIN_BLK is not used for keeping the keys loaded </td><td class="markdownTableBodyNone"><p class="starttd">If you want to upgrade the script but keep the loaded keys on the device, the RETAIN_BLK should be used instead of DEF_BLK in the new script to achieve that. The RETAIN_BLK does not erase the block values when upgrading a script. For VSS version 6.0 and higher you use fixed retain block value of ASCII hex value of the name of the previous script. For earlier versions/other retain block value must be a cryptogram, which has the following computation rules:</p>
<p class="endtd">CODE = TDES[KLK xor(NAME | NAME)] (NAME), where:<br  />
* NAME is the 8-character name of the script to be replaced<br  />
* (NAME | NAME) is the concatenation of two NAMEs to form a 16-byte value that will be exclusive-or’d with KLK to form the double-length encryption key<br  />
* CODE is the result of the triple-DES encryption of NAME under this key<br  />
</p><dl class="section note"><dt>Note</dt><dd>Please note that both scripts (old and new) must have the same script ID (SUBDEV).  </dd></dl>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Using the same script ID while other needed </td><td class="markdownTableBodyNone">One of the typical situations is when the same script ID is used instead of a new one. Please make sure SUBDEV ID is different from the one loaded if you want to load a new script.  </td></tr>
</table>
<h2><a class="anchor" id="VSS_macro_troubleshooting"></a>
VSS macro fails to execute</h2>
<p>This is a section mostly for the VSS API <em>iPS_ExecuteScript()</em> usage. Since the API uses a lot of different input parameters, there are several reason why the scripts execution might fail:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Reason </th><th class="markdownTableHeadNone">Solution/description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Wrong macro ID passed to the API </td><td class="markdownTableBodyNone">Macro ID is defined as "MACRO XXXh", where "XXX" is a value in HEX that serves as an entry point for the macro. One of the regular cases is when the API tries to access the macro number which is not present in a script. Please make sure that the macro with referenced number is actually defined in the VSS script.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wrong script ID passed to the API </td><td class="markdownTableBodyNone">The same as with macro IDs, sometimes wrong script ID is used on the API. Also, with VSS 9.0 and higher, there are user-defined limitations on script ID usage. Please make sure you don't try to execute 'sys' script under the 'usr' user and vice versa. The only exclusion is 'shared' VSS scripts which are installed under the 'uXsys10' Secure installer group (where X is user number). In this case, 'sys10' user can execute 'usrX' VSS scripts, <b>but not vice versa</b>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Script invalid/does not exist </td><td class="markdownTableBodyNone">Before execution of the script, it is recommended to use <em>iPS_GetScriptStatus()</em> API to make sure the script is actually present/valid.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wrong VSSConv version used for script compilation </td><td class="markdownTableBodyNone">All the scripts loaded on the device must be compiled using the VSSConv compiler. However, depending on the VSS version, there are commands that are not implemented. Before command usage make sure you are using the corresponding VSSConv/VSS version. The full list of available VSS version commands can be found in VSS Documentation, while the current VSS version used on the device is obtainable via pcPS_GetVSSVersion() API.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Incorrect API usage order </td><td class="markdownTableBodyNone"><p class="starttd">To make sure that script is executed correctly, the following API usage is recommended:</p>
<p class="endtd">1. <em>iPS_GetScriptStatus()</em> - Make sure the script is present and valid.<br  />
2. <em>iPS_LoadSysClearKey()/iPS_LoadSysEncKey()</em> - Load the System/Key Loading Key. Can be done only once.<br  />
3. <em>iPS_LoadMasterClearKey()/iPS_LoadMasterEncKey()</em> - Load Master key <b>in the correspinding script ID slots 0 and 1</b>. You can also check the status of Master key with <em>iPS_CheckMasterKey()</em> API if already loaded. Script execution will fail on some commands due to Master Key required for some operations. This is recommended for any command though.<br  />
4. <em>iPS_ExecuteScript()</em> - Now, after we made sure we have all the required keys loaded, the script can be actually executed.  </p>
</td></tr>
</table>
<h2><a class="anchor" id="VSS_package_troubleshooting"></a>
VSS script package fails to install</h2>
<p>Aside from the regular Secure installer errors on package installation, there are two specific cases for the VSS packages:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Reason </th><th class="markdownTableHeadNone">Solution/description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VSS package contains dirs/files that are not .vso script </td><td class="markdownTableBodyNone">The VSS package must contain the CONTROL file and the compiled VSS script <b>only</b>.<br  />
Having any other files or directory inside the VSS package is not allowed. All the VSS scripts are installed in /etc/vss/<em>username</em> directories and that structure must not be modified by the internal package structure on installation.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Incorrect group/type defined in the CONTROL file </td><td class="markdownTableBodyNone"><p class="starttd">The CONTROL file for the VSS package must comply with the following rules:<br  />
The package type must be defined as 'vss'<br  />
If you are using the VSS 9.0 or higher and want to share the uploaded script between 'usrX' and 'sys10', the package group must be specified as 'uXsys10'. <br  />
<b>Note that this group can be used with VSS 9.0 and higher and ADK 4.8+</b>. Usage of the mentioned group on installation will lead to package installation error.<br  />
If you are using the VSS 9.0 or higher and want to stop sharing scripts between 'usrX' and 'sys10', the package group must be specified as 'usrX'.<br  />
Below are the sample CONTROL files for regular and 'shared' VSS script packages: </p>
<p class="intertd"><b>'Shared' VSS script</b>:<br  />
Package: sample-vss-script<br  />
Version: 1.0.0<br  />
User: usr1<br  />
Group: u1sys10<br  />
Type: vss</p>
<p class="endtd"><b>Regular VSS script</b>:<br  />
Package: generated-0<br  />
Version: 1.0.0<br  />
User: usr1<br  />
Type: vss  </p>
</td></tr>
</table>
<h2><a class="anchor" id="VSS_removal_troubleshooting"></a>
VSS scripts not removed by SI</h2>
<p>The VSS packages are a special case for removal for the SI. If you want to remove the scripts, 'removevss' command should be used in the remove bundle 'remove' file <b>along with 'removeall' command</b>. If you use any of them separately, the VSS scripts will not be unregistered. Here is an example of 'remove' file that removes both binary bundle and the VSS scripts that it is using:</p>
<p><b>'removevss' example:</b> </p><div class="fragment"><div class="line">removebundle bndl.vos-bin-usr</div>
<div class="line">removeall</div>
<div class="line">removevss</div>
</div><!-- fragment --><p> <br  />
</p>
<h1><a class="anchor" id="sec_vss_acronyms"></a>
Acronyms Definition</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Acronym </th><th class="markdownTableHeadNone">Definitions  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AES </td><td class="markdownTableBodyNone">Advanced Encryption Standard selected by NIST.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CBC </td><td class="markdownTableBodyNone">Cipher Block Chaining mode, as defined in ANSI X3.106.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VSS </td><td class="markdownTableBodyNone">VeriShield Security Scripts.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">DES </td><td class="markdownTableBodyNone">Data Encryption Standard, as defined in ANSI X3.92.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DUKPT </td><td class="markdownTableBodyNone">Derived Unique Key Per Transaction Method as defined in the VISA‘s POS Equipment Requirement: PIN processing and Data Authentication, International Version 1.0, August 1988.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ECB </td><td class="markdownTableBodyNone">Electronic Code Book mode, as defined in ANSI X3.106.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MAC </td><td class="markdownTableBodyNone">Message Authentication Code, as defined in ANSI X9.19.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PIN </td><td class="markdownTableBodyNone">Personal Identification Number.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">POS </td><td class="markdownTableBodyNone">Point-of-Sale.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PP1000+ </td><td class="markdownTableBodyNone">Verifone’s PINpad 1000 plus.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PRD </td><td class="markdownTableBodyNone">Product Requirement Document.  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="a_web_service_wrappers_8c_html_a6e248376c0290338633d8137822eb209"><div class="ttname"><a href="_web_service_wrappers_8c.html#a6e248376c0290338633d8137822eb209">value</a></div><div class="ttdeci">char value(char c)</div><div class="ttdef"><b>Definition:</b> WebServiceWrappers.c:86</div></div>
<div class="ttc" id="anamespacevfisdi_html_a28287671eaf7406afd604bd055ba4066a936c4a5547a9360243178f726f6b2715"><div class="ttname"><a href="namespacevfisdi.html#a28287671eaf7406afd604bd055ba4066a936c4a5547a9360243178f726f6b2715">vfisdi::FAIL</a></div><div class="ttdeci">@ FAIL</div><div class="ttdef"><b>Definition:</b> sdi_enum.h:12</div></div>
<div class="ttc" id="anamespacevficom_1_1cmdparam_1_1in_1_1stk__write_1_1msg_1_1tr_1_1refresh_html_a625b9748e49ec8ee41ab3546a32415c0"><div class="ttname"><a href="namespacevficom_1_1cmdparam_1_1in_1_1stk__write_1_1msg_1_1tr_1_1refresh.html#a625b9748e49ec8ee41ab3546a32415c0">vficom::cmdparam::in::stk_write::msg::tr::refresh::result</a></div><div class="ttdeci">const COM3_DllSpec char result[]</div><div class="ttdoc">integer</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Application Development Kit (ADK)</a></li><li class="navelem"><a class="el" href="adk_programming_interfaces.html">ADK Programming Interfaces</a></li><li class="navelem"><a class="el" href="pg_vss_documentation.html">VeriShield Security Scripts (VSS)</a></li>
    <li class="footer">Generated on Mon Jun 16 2025 16:04:02 for ADK-Programmers-Guides by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
